<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KyXu Tech</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2016-12-15T07:54:35.000Z</updated>
  <id>/</id>
  
  <author>
    <name>KyXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Carthage 摆脱 Bridging-Header.h</title>
    <link href="/2016/12/15/%E7%94%A8-Carthage-%E6%91%86%E8%84%B1-Bridging-Header-h/"/>
    <id>/2016/12/15/用-Carthage-摆脱-Bridging-Header-h/</id>
    <published>2016-12-15T07:54:05.000Z</published>
    <updated>2016-12-15T07:54:35.000Z</updated>
    
    <content type="html">&lt;p&gt;鉴于现在大部分 iOS 常用库都还是用 OC 实现的，我们常常需要用到一个叫做 &lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bridging-Header.h&lt;/a&gt; 的东西来在 Swift 项目中使用 OC 实现的框架，&lt;strong&gt;当然前提是在这个项目里我们不能或者不想使用 Cocoapods 或 Carthage&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 iOS 8 之后，我们可以使用 &lt;a href=&quot;https://skyline75489.github.io/post/2015-8-14_ios_static_dynamic_framework_learning.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;framework&lt;/a&gt; 了，相比于麻烦地操作一遍一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个 Bridging-Header.h 文件&lt;/li&gt;
&lt;li&gt;在 target（还要注意不能是 project）的 Build Settings 找到 Objective-C Bridging Header 项&lt;/li&gt;
&lt;li&gt;然后在里面填上路径，还要注意一下 绝对/相对 路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我更愿意直接把 xxx.framework 放到项目里，然后使用的时候在顶部写上 &lt;code&gt;import XXX&lt;/code&gt;。如果这个框架是 AFNetworking 的话，我们可以在它的 &lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;releases&lt;/a&gt; 页面下载到 &lt;strong&gt;AFNetworking.framework.zip&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/27c8704388d6f6137d4f672af6f9329e.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;但更多像 &lt;a href=&quot;https://github.com/SVProgressHUD/SVProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVProgressHUD&lt;/a&gt; 这样的框架，你只能找到源码，并没有现成的 framework 文件给你用。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/da901c48d1dbf1d12c5626e9a250f22e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;利用_Carthage_打包_framework&quot;&gt;利用 Carthage 打包 framework&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/64013d4372bd5bd7e8999120be2d7063.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;好在它支持了 Carthage。创建了一个文件夹，里面初始只有一个 cartfile&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/547a33d675aed3289be830eee1a3626c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;cartfile 里面随便写了俩常用框架&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/2f93c7519436e64527f9dd6246efe674.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;在终端执行 &lt;code&gt;carthage update&lt;/code&gt; 之后&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006y8lVagw1fariuwlecgj30mp06g3ze.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;现在我们可以直接把打包好的 framework 文件复制到项目里使用了，以后想用什么框架都可以在这个 cartfile 里面添加，在这个文件夹里取用 framework。&lt;/p&gt;
&lt;p&gt;说白了就是一个利用 Carthage 找 framework 文件的方法。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果你想通过自行编译源码，然后在 Products 文件夹里取用 framework，可能这个文件的架构会有问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/a84e3c3788aa509b1ff9&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/4a9d2be042a49e5befba&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/7180d99521ed7d6e5e01&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于现在大部分 iOS 常用库都还是用 OC 实现的，我们常常需要用到一个叫做 &lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bridging-Header.h&lt;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用泛型简化 instantiateViewController</title>
    <link href="/2016/11/03/%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8C%96-instantiateViewController/"/>
    <id>/2016/11/03/用泛型简化-instantiateViewController/</id>
    <published>2016-11-03T08:36:49.000Z</published>
    <updated>2016-11-03T08:37:28.000Z</updated>
    
    <content type="html">&lt;p&gt;使用 storyboard 的时候，我们经常会写出下面这样的代码，用来跳转到其他页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? EditVC {
    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController?.pushViewController(editVC, animated: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最多改成这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实在是太冗长了，简化第一步，或许我们可以直接将 &lt;code&gt;EditVC&lt;/code&gt; 这个类型字符串化变成  &lt;code&gt;“EditVC”&lt;/code&gt;，代码变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;guard &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(describing: EditVC.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? EditVC &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;嗯，更长了，但是既然 &lt;code&gt;EditVC&lt;/code&gt; 使用了两次，这使得我们有机会把这个过程封装成一个函数，而 &lt;code&gt;EditVC&lt;/code&gt; 是唯一需要传递的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;instantiateVC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vc:UIViewController)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(describing: vc.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; storyboard?.instantiateViewController(withIdentifier: id)
}

&lt;span class=&quot;comment&quot;&gt;// how to use&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(vc: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;()) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;封装之后依然尴尬：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为我们不能确定每次都需要函数返回 &lt;code&gt;EditVC&lt;/code&gt; ，所以只能用 &lt;code&gt;UIViewController&lt;/code&gt; 当做返回值，这使得我们还需要再加上 &lt;code&gt;as? EditVC&lt;/code&gt; 去做类型转换，相当于还是手动使用了两次 &lt;code&gt;EditVC&lt;/code&gt; ，而不是一次&lt;/li&gt;
&lt;li&gt;传入的参数是 &lt;code&gt;EditVC()&lt;/code&gt;  而不是  &lt;code&gt;EditVC&lt;/code&gt; ，看起来丑陋&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一次解决两个问题的答案是：泛型！&lt;/p&gt;
&lt;p&gt;我们在函数中限定泛型 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;UIViewController&lt;/code&gt; ，但 &lt;code&gt;T&lt;/code&gt; 具体是我们的 App 中的哪个子类我们不去管，通过函数的参数来指定 T 的具体类型，随后确定出我们函数的返回值为那个我们指定的 &lt;code&gt;T&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;instantiateVC&lt;/span&gt;&lt;span class=&quot;generics&quot;&gt;&amp;lt;T: UIViewController&amp;gt;&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(type: T.&lt;span class=&quot;keyword&quot;&gt;Type&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;? {
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(describing: &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; storyboard?.instantiateViewController(withIdentifier: id) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;
    }
}

&lt;span class=&quot;comment&quot;&gt;// how to use&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(type: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;前后对比：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// before&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }

&lt;span class=&quot;comment&quot;&gt;// after&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(type: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;&lt;br&gt;这里我假装这个函数回避掉了直接使用字符串去传入 &lt;code&gt;Storyboard ID&lt;/code&gt; 的风险，但可以这么做的前提是，这里的 &lt;code&gt;EditVC&lt;/code&gt; 到 &lt;code&gt;“EditVC”&lt;/code&gt; 可以直接字符串化。&lt;/p&gt;
&lt;p&gt;如果你也要这么做的话，至少要保证你的类名的字符串化的结果和你的 &lt;code&gt;Storyboard ID&lt;/code&gt; 是有固定关联的。比如 &lt;code&gt;EditVC&lt;/code&gt; 对应 &lt;code&gt;“editvc”&lt;/code&gt; 或 &lt;code&gt;“EDITVC”&lt;/code&gt; 或 &lt;code&gt;“editVC”&lt;/code&gt; （这样你只要修改字母大小写就可以了），而不是 &lt;code&gt;“abc123”&lt;/code&gt; 这种随便写的东西。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;使用 storyboard 的时候，我们经常会写出下面这样的代码，用来跳转到其他页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>tableView updates 对比 reloadData</title>
    <link href="/2016/10/11/tableView-updates-%E5%AF%B9%E6%AF%94-reloadData/"/>
    <id>/2016/10/11/tableView-updates-对比-reloadData/</id>
    <published>2016-10-11T11:12:12.000Z</published>
    <updated>2016-10-11T11:13:10.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/updatesCompareReload.png&quot; alt=&quot;Paste_Image.png&quot;&gt;&lt;br&gt;如图有一个 TableView，每行显示这一行是第几行，现在我希望每按一次 update 按钮，就动态地在下方加两行。那么简单粗暴的做法是  ，更改数据源，然后刷新一下列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableView.reloadData()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用膝盖想也知道，这会使得前四行没有被改动的地方也被刷新一遍，带来了不必要的性能损耗。&lt;br&gt;好一点的做法是下面这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableView.beginUpdates()
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; indexPaths = [&lt;span class=&quot;type&quot;&gt;IndexPath&lt;/span&gt;(row: tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, section: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;IndexPath&lt;/span&gt;(row: tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, section: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)]
    tableView.insertRows(at: indexPaths, with: &lt;span class=&quot;type&quot;&gt;UITableViewRowAnimation&lt;/span&gt;.automatic)
    tableView.endUpdates()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与上面相比，这样做使得 &lt;code&gt;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell&lt;/code&gt; 方法被少调用了四次。&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;beginUpdates&lt;/code&gt; 和 &lt;code&gt;endUpdates&lt;/code&gt; 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。鉴于我这里只进行了一次 insert 操作，把这两条语句去掉也没事，但是出于规范还是应该写上，因为假如习惯不写，下面这样的代码会运行时崩溃：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@IBAction func &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;(_ sender: AnyObject) {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;\(tableData.count)&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;\(tableData.count)&quot;&lt;/span&gt;)
    //        tableView.beginUpdates()
    tableView.insertRows(&lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt;: [IndexPath(&lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt;: tableData.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;section&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)], &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;: UITableViewRowAnimation.&lt;span class=&quot;keyword&quot;&gt;automatic&lt;/span&gt;)
    tableView.insertRows(&lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt;: [IndexPath(&lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt;: tableData.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;section&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)], &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;: UITableViewRowAnimation.&lt;span class=&quot;keyword&quot;&gt;automatic&lt;/span&gt;)
    //        tableView.endUpdates()
}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为第一次 insert 之后，当前 row 的总数量在 UI 上试图 4 变成 5，然而数据源是 6，它会检查使用者对 tableView 的 UI 操作，最后是不是和 numberOfRows 方法获取的值相对应。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;numberOfRows 方法调用：&lt;/strong&gt; 都只调用一次 numberOfRows 方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cellForRow 方法调用次数：&lt;/strong&gt; reloadData 会为当前显示的所有cell调用这个方法，updates 只会为新增的cell调用这个方法&lt;br&gt;&lt;strong&gt;cellForRow 方法调用时间：&lt;/strong&gt; reloadData 会在 numberOfRows 方法调用后的某一时间异步调用 cellForRow 方法，updates 会在 numberOfRows 方法调用后马上调用 cellForRow 方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reloadData 方法缺陷：&lt;/strong&gt; 带来额外的不必要开销，缺乏动画&lt;br&gt;&lt;strong&gt;updates 方法缺陷：&lt;/strong&gt;deleteRows 不会调用 cellForRow 方法，可能导致显示结果与数据源不一致；需要手动保证 insertRows、deleteRows 之后，row 的数量与 numberOfRows 的结果一致，否则会运行时崩溃&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;部分文章中没有写，总结提到了的部分放在完整 demo 里面了：&lt;a href=&quot;https://github.com/OpenMarshall/TableViewExplore&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo Github 地址&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/updatesCompareReload.png&quot; alt=&quot;Paste_Image.png&quot;&gt;&lt;br&gt;如图有一个 TableView，每行显示这一行是第几行，现在我希望每按一次
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用 UIPickerView 选择精确到街道的中国行政区划位置</title>
    <link href="/2016/08/26/%E7%94%A8-UIPickerView-%E9%80%89%E6%8B%A9%E7%B2%BE%E7%A1%AE%E5%88%B0%E8%A1%97%E9%81%93%E7%9A%84%E4%B8%AD%E5%9B%BD%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E4%BD%8D%E7%BD%AE/"/>
    <id>/2016/08/26/用-UIPickerView-选择精确到街道的中国行政区划位置/</id>
    <published>2016-08-26T06:17:22.000Z</published>
    <updated>2016-08-26T06:18:19.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/KYDivisionPickerViewScreenShot.png&quot; alt=&quot;ScreenShot&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，做了一个四列的 &lt;code&gt;UIPickerView&lt;/code&gt;，可以滑动选择精确到街道的中国行政区划信息，并返回地址，使用简单，直接像平时使用 &lt;code&gt;UIPickerView&lt;/code&gt; 一样，设置好  &lt;code&gt;frame&lt;/code&gt;，添加进父视图就好了。&lt;/p&gt;
&lt;p&gt;实现相应协议中的方法，可以在选择了地址之后，获取到相应地址信息的字符串，有兴趣欢迎戳进 &lt;a href=&quot;https://github.com/OpenMarshall/KYDivisionPickerView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目 Github 地址&lt;/a&gt;，随手 ✨✨✨✨✨&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/KYDivisionPickerViewScreenShot.png&quot; alt=&quot;ScreenShot&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，做了一个四列的 &lt;code&gt;UIPickerVie
    
    </summary>
    
    
      <category term="开源" scheme="/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>父视图外部子视图点击响应 - hitTest</title>
    <link href="/2016/08/19/%E7%88%B6%E8%A7%86%E5%9B%BE%E5%A4%96%E9%83%A8%E5%AD%90%E8%A7%86%E5%9B%BE%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94-hitTest/"/>
    <id>/2016/08/19/父视图外部子视图点击响应-hitTest/</id>
    <published>2016-08-19T03:36:55.000Z</published>
    <updated>2016-08-19T03:40:23.000Z</updated>
    
    <content type="html">&lt;p&gt;面试被问过两次了的一个问题，记录一下：&lt;strong&gt;假如一个 UIView（我们称作 FatherView），有一个 subview（我们称作 ChildView），这个 ChildView 在 FatherView 的 frame 外部，那么默认情况下，这个 ChildView 被点击的时候，并不会触发 FatherView 的点击响应链（这是合情合理的，FatherView 所在的位置都没被点击，它不遍历 subviews，不作回应是正常的），这时候怎样才能让这个 ChildView 相应点击事件？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实思路是很简单的，监控屏幕上的所有点击事件的区域，如果这个区域和我们的 UIView 以及其 subview 的 CGRect 有重合，就作出反应。&lt;/p&gt;
&lt;p&gt;也很容易查到 UIKit 提供了一个现成的方法来做到这件事：&lt;br&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Hit%20Testing%20a%20View.png&quot; alt=&quot;Hit Testing in a View&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Screen%20Shot.png&quot; alt=&quot;Screen Shot&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码是很简单的，现在让灰色的视图作为父视图，蓝色、红色的作为子视图，只要灰色视图实现了上述方法，就可以让蓝色视图像红色视图一样，可以相应点击事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Code%20Snippet.png&quot; alt=&quot;Code Snippet&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Code%20Snippet2.png&quot; alt=&quot;Code Snippet&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OpenMarshall/HitTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;完整 Demo Github 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此都是很简单的内容，需要注意的如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你会发现 FatherView 里面的这个 &lt;code&gt;HitTest&lt;/code&gt; 会被频繁执行，你随便点击一个空白处，这个方法都会执行，这必然带来性能消耗，这也是 Apple 默认不使用这个方式的原因之一吧&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HitTest&lt;/code&gt; 会使得我们的蓝色的 UIView 可以相应点击，但是它被点击的之后，执行的方法我们应该按常规的方式写（比如给它加一个 &lt;code&gt;UIGestureRecognizer&lt;/code&gt; ，然后让这个 Gesture 有一个对应的 selector）。如果把需要执行的方法写在了 &lt;code&gt;HitTest&lt;/code&gt; 里面，写在 &lt;code&gt;return result&lt;/code&gt; 之前的话，我发现这些方法会多执行一次（在我当前写的这个简单 demo 里，我发现点击任意地方，&lt;code&gt;HitTest&lt;/code&gt; 方法都会连续执行两次）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://zhoon.github.io/ios/2015/04/12/ios-event.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;延伸阅读 - 深入浅出 iOS 事件机制&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;面试被问过两次了的一个问题，记录一下：&lt;strong&gt;假如一个 UIView（我们称作 FatherView），有一个 subview（我们称作 ChildView），这个 ChildView 在 FatherView 的 frame 外部，那么默认情况下，这个 Child
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>想一下再用 guard</title>
    <link href="/2016/07/18/%E6%83%B3%E4%B8%80%E4%B8%8B%E5%86%8D%E7%94%A8-guard/"/>
    <id>/2016/07/18/想一下再用-guard/</id>
    <published>2016-07-18T08:33:40.000Z</published>
    <updated>2016-07-18T08:34:09.000Z</updated>
    
    <content type="html">&lt;p&gt;自从知道了 &lt;code&gt;guard let&lt;/code&gt; 这种写法之后，我就几乎换掉了所有 &lt;code&gt;if let&lt;/code&gt; 写法。但今天要提醒一下，使用 &lt;code&gt;guard let&lt;/code&gt; 之前，需要先思考一下，因为这并不总是万全的解放方案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// bad&lt;/span&gt;
&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createMan0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: String?, country: String?, age: Int?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = name {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; country = country {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age = age {
                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;(name: name, country: country, age: age)
            }
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;comment&quot;&gt;// good&lt;/span&gt;
&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createMan1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: String?, country: String?, age: Int?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = name &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; country = country &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age = age &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;(name: name, country: country, age: age)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上的代码是很常见的 &lt;code&gt;guard let&lt;/code&gt; 使用场景，为了避免让我们写出 “Swift 鞭尸金字塔”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NetworkState&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Wifi&lt;/span&gt;
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(state:NetworkState)&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; state {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;:
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; speed = networkSpeed &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Cellular Speed: &lt;span class=&quot;subst&quot;&gt;\(speed)&lt;/span&gt;&quot;&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Wifi&lt;/span&gt;:
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; speed = networkSpeed &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Wifi Speed: &lt;span class=&quot;subst&quot;&gt;\(speed)&lt;/span&gt;&quot;&lt;/span&gt;)
    }
    &lt;span class=&quot;comment&quot;&gt;// 可能无法被执行&lt;/span&gt;
    doSomething()
}

test(.&lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这种情况下，如果我们一看到 &lt;code&gt;networkSpeed&lt;/code&gt; 是可选型的，就决定使用 &lt;code&gt;guard … else {return}&lt;/code&gt; 语法，那么会出现的结果就是一旦 &lt;code&gt;networkSpeed&lt;/code&gt; 值为 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;doSomething()&lt;/code&gt; 将不会被执行。我们一开始可能仅仅是希望无法获取网速数值的时候，不在控制台打印相应信息，但现在整个 &lt;code&gt;test()&lt;/code&gt; 都被提前退出了。解决这个问题很简单，把 &lt;code&gt;guard … else {return}&lt;/code&gt; 改成  &lt;code&gt;guard … else {break}&lt;/code&gt;，让 &lt;code&gt;switch - case&lt;/code&gt; 里面的代码段提前退出就可以了。&lt;/p&gt;
&lt;p&gt;但是并不一定每种情况我们都要回避使用 &lt;code&gt;guard … else {return}&lt;/code&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;File&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Keynote&lt;/span&gt;
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;saveInBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( completion: File-&amp;gt;Void )&lt;/span&gt;&lt;/span&gt; {
    completion(.&lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;)
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;closureTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
    saveInBackground( { file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; file {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = fileName &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Pages: &lt;span class=&quot;subst&quot;&gt;\(name)&lt;/span&gt;&quot;&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Keynote&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = fileName &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Keynote: &lt;span class=&quot;subst&quot;&gt;\(name)&lt;/span&gt;&quot;&lt;/span&gt;)
        }
    })
    &lt;span class=&quot;comment&quot;&gt;// 一定会被执行&lt;/span&gt;
    doSomething()
}

closureTest()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种情况下，&lt;code&gt;return&lt;/code&gt; 所退出的方法是 &lt;code&gt;saveInBackground&lt;/code&gt; 函数里面的闭包 &lt;code&gt;completion: File-&amp;gt;Void&lt;/code&gt;，&lt;code&gt;saveInBackground&lt;/code&gt; 本身不受影响，如果 &lt;code&gt;saveInBackground&lt;/code&gt; 里面还有其他参数是闭包，那么其他闭包自然也不受影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;configureButton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(button:UIButton, buttonTitle:String?, buttonImage:UIImage?)&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; title = buttonTitle {
        button.setTitle(title, forState: .&lt;span class=&quot;type&quot;&gt;Normal&lt;/span&gt;)
    }
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; image = buttonImage {
        button.setImage(image, forState: .&lt;span class=&quot;type&quot;&gt;Normal&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在这种情况，&lt;code&gt;if let&lt;/code&gt; 语法就很自然，有 title 我们就设置 title，有 image 我们就设置 image，没有就算了，总不能说没有 title 或 image 就直接放弃当前的方法，或许我们后面还要做很多其他事情。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;没东西了&quot;&gt;没东西了&lt;/h1&gt;&lt;p&gt;希望大家在使用 &lt;code&gt;guard&lt;/code&gt; 关键字的时候多思考一下，以免犯下低级错误。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自从知道了 &lt;code&gt;guard let&lt;/code&gt; 这种写法之后，我就几乎换掉了所有 &lt;code&gt;if let&lt;/code&gt; 写法。但今天要提醒一下，使用 &lt;code&gt;guard let&lt;/code&gt; 之前，需要先思考一下，因为这并不总是万全的解放方案。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>集成 Weex 注意事项</title>
    <link href="/2016/06/19/%E9%9B%86%E6%88%90-Weex-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>/2016/06/19/集成-Weex-注意事项/</id>
    <published>2016-06-19T15:52:32.000Z</published>
    <updated>2016-06-19T15:53:04.000Z</updated>
    
    <content type="html">&lt;p&gt;撰写本文时，Weex 还没有完全开源，&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a21l5.77726.340855.2&amp;amp;docType=1&amp;amp;articleId=104742&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是官方的文档中心&lt;/a&gt;，&lt;a href=&quot;https://github.com/weexteam/article/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是 Weex 团队放在 Github 上的一些文章&lt;/a&gt;，你可以上&lt;a href=&quot;http://alibaba.github.io/weex/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;申请访问 Weex 的 Github 页面。&lt;/p&gt;
&lt;p&gt;这篇文章介绍一下如何快速集成 Weex 到你的 iOS Project 里面。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果你还没有 Weex 的 SDK，你可以下载一下这个官方给的 &lt;a href=&quot;http://gw.alicdn.com/bao/uploaded/LB1yfvtKpXXXXXbXXXXXXXXXXXX.zip?spm=a219a.7629140.0.0.ZqqSyg&amp;amp;file=LB1yfvtKpXXXXXbXXXXXXXXXXXX.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WeexSample&lt;/a&gt;，工程里面有 WeexSDK.framework 这个文件，这样如果你惯用 Objective-C 的话，参考&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a219a.7629140.0.0.sf2ubW&amp;amp;&amp;amp;docType=1&amp;amp;articleId=104829&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;，你就可以清晰明了地知道这个 Sample 是怎么写出来的，但是这篇文章没有告诉你这些事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里面有两个文件 SRWebSocket.h 和 SRWebSocket.m，这是 facebook 的开源项目 &lt;a href=&quot;https://github.com/facebook/SocketRocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SockerRocket&lt;/a&gt; ，运行这个项目必须有这个东西（至少暂时是这样，或许以后 Weex 团队会尝试自己搞个类似的东西出来？）&lt;/li&gt;
&lt;li&gt;官方目前没有 Swift 版本的 Sample，这里有个来自第三方的&lt;a href=&quot;https://github.com/acton393/WeexSwiftSample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;示例&lt;/a&gt;，可以参考一下，这个示例有一点点问题，代码风格不太 Swifty，问题我写在下面了，其他诸如 print 写成 NSLog 这种，无伤大雅，好歹是用 Swift 运行起来了&lt;/li&gt;
&lt;li&gt;Weex 是用 OC 写的，Swift 项目集成它，里面需要桥接文件，如果你不知道这个是什么，可以参考我&lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;之前的一篇文章&lt;/a&gt;，这个文件里面只需要写这些（不需要 import SRWebSocket）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXSDKEngine.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXSDKInstance.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXLog.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXAppConfiguration.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;官方展示的 OC 版本的这段代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;
{
    &lt;span class=&quot;attr_selector&quot;&gt;[_instance destroyInstance]&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Swift 里面的写法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// Deprecated&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//    override func finalize() {&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//        instance.destroyInstance()&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//    }&lt;/span&gt;

deinit {
    &lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt;.destroyInstance()
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虽然官方在很多地方都提到这一点，为了防止还是有人忽略，再写一遍：请在 Build Settings 的 Other Link Flags 里面加入 &lt;strong&gt;-ObjC&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网开源的代码中，没有把 SDK 做成 .framework，而是直接一个文件夹，工程通过 Pod 来把这个 SDK 集成到项目中，顺便也通过 Pod 集成了其他内容，这是 Podfile 里的内容（可以看到 WeexSDK 是通过本地路径加进来的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source &lt;span class=&quot;string&quot;&gt;&#39;https://github.com/CocoaPods/Specs.git&#39;&lt;/span&gt;
platform &lt;span class=&quot;symbol&quot;&gt;:ios&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;7.0&#39;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;#inhibit_all_warnings!&lt;/span&gt;

target &lt;span class=&quot;string&quot;&gt;&#39;WeexDemo&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;WeexSDK&#39;&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:path=&amp;gt;&lt;span class=&quot;string&quot;&gt;&#39;../sdk/&#39;&lt;/span&gt;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;SDWebImage&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;3.7.5&#39;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;SocketRocket&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;0.4.2&#39;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;ATSDK-Weex&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;0.0.1&#39;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;撰写本文时，Weex 还没有完全开源，&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a21l5.77726.340855.2&amp;amp;docType=1&amp;amp;articleId=104742&quot; target=&quot;_bla
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Controller 之间使用代理传值</title>
    <link href="/2016/05/18/Controller-%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E4%BC%A0%E5%80%BC/"/>
    <id>/2016/05/18/Controller-之间使用代理传值/</id>
    <published>2016-05-17T16:53:52.000Z</published>
    <updated>2016-05-17T16:54:31.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/delegatePassData.gif&quot; alt=&quot;Controller 传值&quot;&gt;&lt;br&gt;控制器之间经常需要互相传递值，第一个控制器（简称 MasterVC）在通过 NavigationController Push 第二个控制器（简称 DetailVC）的时候，可以捕获到 DetailVC，所以可以设定后者的变量。而 DetailVC 在给 MasterVC 传递值的时候，比如设定 MasterVC 的 Title，却不能用同样的方式传值（试一下就知道了），而且因为我们要通过 NavigationController 返回原来的界面而不是 push 一个新的界面，所以也不能通过 segue 传值，解决方法我尝试了两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 static var&lt;/li&gt;
&lt;li&gt;使用代理传值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用_static_var&quot;&gt;使用 static var&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MasterVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; text:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;! = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewWillAppear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(animated: Bool)&lt;/span&gt;&lt;/span&gt; {
        title = &lt;span class=&quot;type&quot;&gt;MasterVC&lt;/span&gt;.text
    }
}

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DetailVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewWillDisappear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(animated: Bool)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;type&quot;&gt;MasterVC&lt;/span&gt;.text = &lt;span class=&quot;string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样虽然行得通，但是代码丑陋：类似 viewWillAppear 这样的方法，让人难以读懂，为什么这样的事情要在这个地方做，没有明显的道理；在 MasterVC 内部，仍然需要以 &lt;code&gt;MasterVC.text&lt;/code&gt; 这样蹩脚的方式调用。&lt;/p&gt;
&lt;h2 id=&quot;使用代理传值&quot;&gt;使用代理传值&lt;/h2&gt;&lt;p&gt;说白了我们只是希望 MasterVC 有一个 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 这样的方法，然后在 DetailVC 里面适时地调用这个方法就好了。于是解决方案是：将 MasterVC 设为 DetailVC 的代理，DetailVC 以代理作为桥梁，来调用 MasterVC 里面的 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 方法，而 MasterVC 只需要遵守一个相应的传值协议，协议里面要求必须实现的方法，就是 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 这个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;//  PassDataDelegate.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Foundation

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PassDataDelegate&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setControllerTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text:String)&lt;/span&gt;&lt;/span&gt;
}


&lt;span class=&quot;comment&quot;&gt;//  MasterVC.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MasterVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;PassDataDelegate&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;preprocessor&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textField: &lt;span class=&quot;type&quot;&gt;UITextField&lt;/span&gt;!

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - Pass Data&lt;/span&gt;
    &lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;goNextController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vc = storyboard?.instantiateViewControllerWithIdentifier(&lt;span class=&quot;string&quot;&gt;&quot;DetailVC&quot;&lt;/span&gt;)
            &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;DetailVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; txt = textField.text &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
        vc.title = txt &lt;span class=&quot;comment&quot;&gt;// pass data&lt;/span&gt;
        vc.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// get data by set delegate&lt;/span&gt;
        navigationController?.pushViewController(vc, animated: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - PassDataDelegate Method&lt;/span&gt;
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setControllerTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text:String)&lt;/span&gt;&lt;/span&gt; {
        title = text
    }

}


&lt;span class=&quot;comment&quot;&gt;//  DetailVC.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DetailVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;preprocessor&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textField: &lt;span class=&quot;type&quot;&gt;UITextField&lt;/span&gt;!
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delegate: &lt;span class=&quot;type&quot;&gt;PassDataDelegate&lt;/span&gt;!

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - Pass Data&lt;/span&gt;
    &lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;goBackLastController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; delegate != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; txt = textField.text &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
            delegate.setControllerTitle(txt)
        }
        navigationController?.popViewControllerAnimated(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相比之前的方法，我们获得的额外的好处是：假如我们传递的不只是字符串，而是大量的信息，比如十个不同类型的值，使用代理传值依然只需要实现一个方法，而在之前的解决方案中，我们需要写十行 &lt;code&gt;static var&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OpenMarshall/PassDataByDelegate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;完整项目&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/delegatePassData.gif&quot; alt=&quot;Controller 传值&quot;&gt;&lt;br&gt;控制器之间经常需要互相传递值，第一个控制器（简称 MasterVC）在通过 Navig
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 结合 UISearchBar 问题解决</title>
    <link href="/2016/05/06/UITableView-%E7%BB%93%E5%90%88-UISearchBar-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>/2016/05/06/UITableView-结合-UISearchBar-问题解决/</id>
    <published>2016-05-06T09:36:26.000Z</published>
    <updated>2016-05-06T09:36:55.000Z</updated>
    
    <content type="html">&lt;p&gt;之前看了 &lt;a href=&quot;https://www.raywenderlich.com/113772/uisearchcontroller-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ray Wenderlich 的一篇文章&lt;/a&gt; 学习了一下怎么把 UISearchBar 放在 UITableView 的头部，来进行列表搜索，然后发现了两个问题，用了好久才解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UISearchBar 有个 1 像素宽的黑色边框，去不掉&lt;/li&gt;
&lt;li&gt;把 UISearchBar 放在 UITableView 头部的代码在 iOS 8 不起作用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;tableView&lt;span class=&quot;class&quot;&gt;.tableHeaderView&lt;/span&gt; = searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// now working&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;解决问题_1&quot;&gt;解决问题 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.layer&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.borderWidth&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;
searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.layer&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.borderColor&lt;/span&gt; = &lt;span class=&quot;comment&quot;&gt;// your background color&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;解决问题_2&quot;&gt;解决问题 2&lt;/h3&gt;&lt;p&gt;我发现 tableHeaderView 是可以被其他 view 有效填充的，不知道为什么 searchBar 就是放不进去，所以直接找个大小一样的 UIView 作为容器放在 searchBar 下面就好了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let containerView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, view.frame.width, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)
containerView&lt;span class=&quot;class&quot;&gt;.backgroundColor&lt;/span&gt; = &lt;span class=&quot;comment&quot;&gt;// your background color&lt;/span&gt;
searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.frame&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;CGRectMake&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, view.frame.width, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
containerView.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;addSubview&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(searchController.searchBar)&lt;/span&gt;&lt;/span&gt;
tableView&lt;span class=&quot;class&quot;&gt;.tableHeaderView&lt;/span&gt; = containerView
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;之前看了 &lt;a href=&quot;https://www.raywenderlich.com/113772/uisearchcontroller-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ray Wenderlich 的一篇文章&lt;/a&gt; 学
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>初识函数式 Swift 实用</title>
    <link href="/2016/04/29/%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0%E5%BC%8F-Swift-%E5%AE%9E%E7%94%A8/"/>
    <id>/2016/04/29/初识函数式-Swift-实用/</id>
    <published>2016-04-29T09:20:15.000Z</published>
    <updated>2016-04-29T09:20:40.000Z</updated>
    
    <content type="html">&lt;p&gt;Swift 的语言特性使得它非常适合被用于以函数式编程思想，如果你还没开始用函数式的方式来使用它，那么可以从现在开始，尝试着利用函数式的便利性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: view.frame)&lt;/span&gt;&lt;/span&gt;
indicateView&lt;span class=&quot;class&quot;&gt;.image&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(named: &lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(indicateView)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我刚刚写了上面这段代码，来让我的当前页面显示名为 “how2use” 的这张图片。看起来好像是我做了三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 frame 创建 UIImageView&lt;/li&gt;
&lt;li&gt;根据图片名称配置 UIImageView&lt;/li&gt;
&lt;li&gt;将 UIImageView 作为 subview 传给其他 view&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是实际上，我只需要 frame、imageName 这两个东西就可以把这三行代码配置好，或者说我能不能用这两个参数来把上面的三行代码缩减为一行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rect:CGRect)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame = rect
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(imageName:String)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.image = &lt;span class=&quot;type&quot;&gt;UIImage&lt;/span&gt;(named: imageName)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;placeSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(view:UIView)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        view.addSubview(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写了上面这些方法之后，代码修改成这个样子了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(view.frame)&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;placeSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self.view)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了代码可读性，这里我写了四行，但显然这是一行代码。&lt;br&gt;继而我发现 indicateView 这个名字没有存在的必要，于是我废弃掉 placeSelf 这个方法，改成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
    .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(view.frame)&lt;/span&gt;&lt;/span&gt;
    .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一行代码，不引入多余的变量。&lt;br&gt;如果你愿意的话，这个模式还可以继续写下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tagSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(tag:Int)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tag = tag
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modeSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(contentMode:UIViewContentMode)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.contentMode = contentMode
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后代码会变成这种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;......
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;上面这些代码的优势在于：类似 indicateView 这种东西，用一次就不要了，没必要引入新的名称，不便于理解和记忆，我们就可以函数式地把它解决掉，代码更精简易读。&lt;/li&gt;
&lt;li&gt;上面我用了 xxxxSelf 这种方式来表明，这种方法不是用一下就完了，它会返回这个对象本身，所以你还可以继续做别的事情。但是这种命名方式我个人看来不够好，唯一好的地方可能只是在于：本来我想设置 imageView.tag = 100，结果敲出 tag 这三个字母，Xcode 就提示我有 tagSelf 这个方法可以用，这可以让我方便地自动补全这个方法，不需要记忆方法名。&lt;/li&gt;
&lt;li&gt;这种编程方式的优点之一在于不同方法之间的组合性，如果你想把上面这些方法整合到一个函数里，然后通过传一大堆的参数来进行调用，是画蛇添足。&lt;/li&gt;
&lt;li&gt;显然这种方式有其弊端，不宜滥用，而且修改代码的时候要注意：假如你要改动 func2，注意它和 func1、func3 之间是不是存在什么先后关系。特别是你用这种方式来给图片做滤镜处理的时候，一张图片先高斯模糊再打马赛克，先打马赛克再高斯模糊是完全不同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;userImage.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;mosaic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 马赛克本身是清晰的&lt;/span&gt;
userImage.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;mosaic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 马赛克本身是模糊的&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 的语言特性使得它非常适合被用于以函数式编程思想，如果你还没开始用函数式的方式来使用它，那么可以从现在开始，尝试着利用函数式的便利性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span c
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 setNeedsLayout 说起</title>
    <link href="/2016/04/27/%E4%BB%8E-setNeedsLayout-%E8%AF%B4%E8%B5%B7/"/>
    <id>/2016/04/27/从-setNeedsLayout-说起/</id>
    <published>2016-04-27T08:01:39.000Z</published>
    <updated>2016-04-27T08:03:43.000Z</updated>
    
    <content type="html">&lt;p&gt;本文从 &lt;code&gt;setNeedsLayout&lt;/code&gt; 这个方法说起，分享与其相关的 UIKit 视图交互、使用场景等内容。&lt;/p&gt;
&lt;p&gt;UIKit 为 UIView 提供了这些方法来进行视图的更新与重绘：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsLayout&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;layoutSubviews&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;layoutIfNeeded&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsDisplay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsDisplayInRect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rect: CGRect)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drawRect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rect: CGRect)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;运行时视图交互模型&quot;&gt;运行时视图交互模型&lt;/h2&gt;&lt;p&gt;无论是用户交互触发还是代码自动触发，下图展示的事件序列都同样适用，这里用到了 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/UIKit%20interactions%20with%20your%20view%20objects.png&quot; alt=&quot;UIKit interactions with your view objects&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图对应的事件序列如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户触摸屏幕&lt;/li&gt;
&lt;li&gt;硬件报告触摸事件给 UIKit 框架 &lt;/li&gt;
&lt;li&gt;UIKit 框架将触摸事件打包成 UIEvent 对象，然后分发给合适的视图&lt;/li&gt;
&lt;li&gt;事件处理代码会对相应事件作出响应，代码可以是这样的：&lt;br&gt;-更改  &lt;code&gt;frame&lt;/code&gt;、&lt;code&gt;bounds&lt;/code&gt;、&lt;code&gt;alpha&lt;/code&gt; 等属性&lt;br&gt;-调用 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法以标记该视图（或者它的子视图）为需要进行布局更新&lt;br&gt;-调用 &lt;code&gt;setNeedsDisplay&lt;/code&gt; 或者 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 方法以标记该视图（或者它的子视图）需要进行重画&lt;br&gt;-通知 Controller 有数据变化&lt;/li&gt;
&lt;li&gt;如果一个视图的几何结构改变了，UIKit 会更新它的子视图&lt;/li&gt;
&lt;li&gt;如果任何视图的任何部分被标记为需要重画，UIKit 会要求视图重画自身&lt;/li&gt;
&lt;li&gt;任何已经更新的视图会与应用余下的可视内容组合在一起，同时被发送到图形硬件去显示&lt;/li&gt;
&lt;li&gt;图形硬件将已解释内容转化到屏幕上&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;方法调用逻辑&quot;&gt;方法调用逻辑&lt;/h2&gt;&lt;p&gt;在上面的过程中，我们可以接触到文章开头提到的方法，他们的调用逻辑是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;setNeedsLayout&lt;/code&gt; 会给当前 UIView 立一个 flag，以表示后续应该调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 方法，以调整当前视图及其子视图的布局。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 会给当前 UIView 立一个 flag，以表示后续应该调用 &lt;code&gt;drawRect:&lt;/code&gt; 方法，以进行视图重绘。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;View_Drawing_Cycle&quot;&gt;View Drawing Cycle&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple 官方文档&lt;/a&gt;已经明确说明，开发者不应该直接调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 与  &lt;code&gt;drawRect:&lt;/code&gt; ，而应该&lt;strong&gt;在你认为系统默认的布局和重绘不能带给你想要的效果时，在子类中重写这些方法，然后分别通过 &lt;code&gt;setNeedsLayout&lt;/code&gt; 和 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 来进行调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然你可以给多个 UIView 设置 &lt;code&gt;setNeedsLayout&lt;/code&gt;，然后当下一个 View Drawing Cycle 到来时，多个 UIView 的视图会一同更改布局。&lt;/p&gt;
&lt;p&gt;那么这个 View Drawing Cycle 到底是什么呢，官方是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The system waits until the end of the current run loop before initiating any drawing operations. This delay gives you a chance to invalidate multiple views, add or remove views from your hierarchy, hide views, resize views, and reposition views all at once. All of the changes you make are then reflected at the same time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然这样用 RunLoop 把多次修改聚集在一个 Cycle 一并进行渲染是更加高效的行为。&lt;/p&gt;
&lt;p&gt;（我个人对 View Drawing Cycle 的理解是这样的：UIKit 需要处理非常多的事件，这些事件组合起来变成了一个非常复杂的事件序列，在这个序列中有些特定的点是 UIKit 专门提供给 UIView 来进行视图更改的。如上所述，在当前 run loop 结束之前，我们有机会做各种视图更改，并且这些更改会在下一个 run loop 体现出来，所以&lt;strong&gt; View Drawing Cycle 就是一次次 run loop 中我们通过 UIKit 得到的 UIView 重布局、重绘机会所组成的循环&lt;/strong&gt;。有理解不对的地方，欢迎评论指正。）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;如何善用_View_Drawing_Cycle&quot;&gt;如何善用 View Drawing Cycle&lt;/h2&gt;&lt;p&gt;一个很常见的例子是，一个 iPad App，横屏和竖屏时界面布局不一样，那么你可以监听设备旋转，在设备旋转时执行 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法，然后在 &lt;code&gt;layoutSubviews&lt;/code&gt; 里面通过判断接下来是横屏还是竖屏来进行不一样的布局设置。基本上你不可能只在这个方法里只进行了单个 UIView 的布局修改，而是多项修改，那么 App 会在下一个 View Drawing Cycle 到来时，把这些修改一起执行，这是最正常的情况。&lt;/p&gt;
&lt;p&gt;那么假如我不按 Apple 规定的来，直接调用 &lt;code&gt;layoutSubviews&lt;/code&gt;  呢？我们可以猜想一下：因为这个方法里面提供了我们需要的布局方式，所以 UIView 会按我们想要的方式来布局，但是因为各种视图修改的请求时机是零碎的，所以这样效率会低一些。所以重要的其实是了解何时会触发 &lt;code&gt;layoutSubviews&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init 初始化不会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;addSubview 会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;设置 view 的 frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化&lt;/li&gt;
&lt;li&gt;滚动一个 UIScrollView 会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件&lt;/li&gt;
&lt;li&gt;改变一个 UIView 大小的时候也会触发父 UIView 上的 layoutSubviews 事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后按 Apple 要求的方式来做就好了（分别通过 &lt;code&gt;setNeedsLayout&lt;/code&gt; 和 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 来调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 和  &lt;code&gt;drawRect:&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;但有些情况比较特殊：你打开 iOS 的时钟应用，去看里面的秒表页面，这个页面里面的两个按钮是没有 UIButton 默认的动画的，点击之后，按钮会瞬间改变自身的状态（颜色、内部 Label 的内容），这种情况我们需要跳出 View Drawing Cycle，来实现一个瞬间改变的效果。实现方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIButton&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickButtonAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;.performWithoutAnimation({
            &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.layoutIfNeeded()
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出 &lt;code&gt;layoutIfNeeded&lt;/code&gt; 作为一个辅助选项给了 &lt;code&gt;setNeedsLayout&lt;/code&gt; 一个可以瞬时执行的特点。当然默认这个“选项”是关闭的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;setNeedsDisplay_补充&quot;&gt;setNeedsDisplay 补充&lt;/h2&gt;&lt;p&gt;&lt;code&gt;setNeedsLayout&lt;/code&gt; 的使用场景之前已经提过了（iPad App），下面举个栗子说一下 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt;的使用场景。&lt;/p&gt;
&lt;p&gt;假如我需要在两点之间绘制一条直线，有两个 &lt;code&gt;dotView&lt;/code&gt;，需要绘制一个 &lt;code&gt;lineView&lt;/code&gt;。我在 &lt;code&gt;drawRect:&lt;/code&gt; 方法里实现了 &lt;code&gt;lineView&lt;/code&gt; 的具体绘制方法（根据两个点来绘制）。那么如果我想要这个直线一直根据两个点同步变化的话，就需要在 &lt;code&gt;dotView&lt;/code&gt; 的位置发生改变时，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lineView.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;setNeedsDisplay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 重绘 lineView&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于 &lt;code&gt;drawRect:&lt;/code&gt; 方法什么时候会被触发：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/From%20StackOverFlow.png&quot; alt=&quot;From StackOverFlow&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个很好的参考链接：&lt;a href=&quot;http://stackoverflow.com/questions/2807137/what-is-the-relationship-between-uiviews-setneedslayout-layoutifneeded-and-lay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is the relationship between UIView’s setNeedsLayout, layoutIfNeeded and layoutSubviews?&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文从 &lt;code&gt;setNeedsLayout&lt;/code&gt; 这个方法说起，分享与其相关的 UIKit 视图交互、使用场景等内容。&lt;/p&gt;
&lt;p&gt;UIKit 为 UIView 提供了这些方法来进行视图的更新与重绘：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在这个行当，不做程序员也得懂技术</title>
    <link href="/2016/04/17/%E5%9C%A8%E8%BF%99%E4%B8%AA%E8%A1%8C%E5%BD%93%EF%BC%8C%E4%B8%8D%E5%81%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF/"/>
    <id>/2016/04/17/在这个行当，不做程序员也得懂技术/</id>
    <published>2016-04-17T04:51:45.000Z</published>
    <updated>2016-04-17T04:52:29.000Z</updated>
    
    <content type="html">&lt;p&gt;先来捋一捋思路，关于各个岗位合作打造（移动端）产品的一点想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么只有程序员是不够的&lt;/li&gt;
&lt;li&gt;如何做一个好的非程序员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;声明：&lt;br&gt;本人是程序员，截止到目前，我用的设计都是自己设计的，我用的产品策略都是自己的思考。&lt;br&gt;本人并非专业设计师或 PM，如果勘误，欢迎指正。&lt;br&gt;本文并非对设计师和 PM 的吐槽，但如果您觉得您作为设计师或 PM 或其他职业者被冒犯了，我只能说我并无此意，请您立刻关闭此页面。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么只有程序员是不够的&quot;&gt;为什么只有程序员是不够的&lt;/h2&gt;&lt;p&gt;&lt;br&gt;首先要消除一下歧义，我们见过无数的一人独挑大梁完爆数十人团队的例子，所以事实证明，只有一个程序员，某些时候是足够的。不够背后隐含的是，这个程序员做了很多非程序员岗位的事情，这种情况下其实相当于是一个 Product Creater 在做东西，他（她）不仅仅是程序员这么简单。&lt;/p&gt;
&lt;p&gt;即便是在移动端出现之前，大家在 PC 上用软件，也是需要有人来做设计，有人来思考产品的。&lt;/p&gt;
&lt;p&gt;用户完成一个操作，需要做几次操作，需要做什么样的操作，PC 上是鼠标左击、右击、滑动还是其他，移动端是滑动、点按、长按亦或重按。这个产品解决了什么样的问题，用什么方式解决的，其他产品解决了这个问题吗，它们是怎么解决的，你和它们相比有什么不同……这款产品有自己的设计风格吗，如果是依照平台的风格，那么有什么地方没遵循平台的规范吗，能不能先破再立，开创一个新的形态……&lt;/p&gt;
&lt;p&gt;类似的问题太多太多，于是有了【程序员+设计师+PM】的模型。&lt;/p&gt;
&lt;p&gt;最近想明白了一件事情：为什么身边好多人我明确地知道他们代码写的比我好，但是做不出好东西？&lt;/p&gt;
&lt;p&gt;去年 8 月份我做了自己的第一款在 App Store 上架的 App，花了 12 天，2000 行 Swift。这个项目如果是现在做的话，从 0 到打包 ipa，两天以内，最多 800 行代码就可以搞定。然而就是这份臃肿不看、风格丑陋的代码，带领这个 App 杀进了 App Store 中国区付费榜 Top 50。&lt;/p&gt;
&lt;p&gt;还有就是现在的编码能力相比从前有了十足的进步，面向协议编程、函数式编程也都有了了解，对可以重构的项目大刀阔斧地更改，改代码的时候心潮那叫一个澎湃啊，觉得自己写出了多么多么厉害的代码。等写完了，冷静一看，原来不过如此。代码是变了，App 表现起来和原来并没有什么区别，这种努力用户是看不见的。&lt;/p&gt;
&lt;p&gt;所以逐渐开始认识到，代码和产品是多么割裂开的事情。当然好的程序员可以把这些事情想办法联系起来，融会贯通，知道什么样的 App 导航模式可能对应背后什么样的设计模式（举了个不好的例子）。但说到底这是完全不同的两件事。&lt;/p&gt;
&lt;h2 id=&quot;如何做一个好的非程序员&quot;&gt;如何做一个好的非程序员&lt;/h2&gt;&lt;p&gt;&lt;br&gt;做外包的经常觉得甲方很蠢、各种难沟通，所谓隔行如隔山，甲方或许会说出 “这个设计看着不大气啊” 或者 “我想做一个淘宝那样的网站，得多少钱” 这样的话，然后乙方就在内心嘲笑人家，但是身体上还要表现的无所谓，最终把钱搞到手。&lt;/p&gt;
&lt;p&gt;但其实真的没必要这样，因为对方是来提出需求的，假如让我进入一个完全没有概念的领域，比如说挑选木材，我也只能说我想要像什么什么一样的木材，我叫不上名字的。所以甲方这样无可厚非。但同时我们也知道，一个好的甲方，我们可能希望他懂技术、懂设计、懂产品，和我们交流起来纵享丝滑。&lt;/p&gt;
&lt;p&gt;程序员、设计师、PM 三方对接的时候，其实就是这么个甲乙方的关系，而理想状况下，这三方中的任何一方充当甲方的时候，都应该是一个可以进行无障碍对接的甲方。&lt;/p&gt;
&lt;p&gt;比如说颜色，设计师眼里的颜色是这样的：&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF0.png&quot; alt=&quot;KUWAZOME&quot;&gt;&lt;br&gt;同样的东西在程序员眼里是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let kuwazomeColor = UIColor(red: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, green: &lt;span class=&quot;number&quot;&gt;54&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, blue: &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, alpha: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么好的设计师应该是以这样的方式把这个颜色传递给程序员的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;# 颜色&lt;/span&gt;
KUWAZOME: R &lt;span class=&quot;number&quot;&gt;0.39&lt;/span&gt; - G &lt;span class=&quot;number&quot;&gt;0.21&lt;/span&gt; - B &lt;span class=&quot;number&quot;&gt;0.23&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KUWAZOME: &lt;span class=&quot;hexcolor&quot;&gt;#6B4449&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;作为设计师，你可以不会写代码，你可以不知道什么是 UIColor 什么是 CGColor 什么是 NSColor，但是你要知道用你的东西的人此时此刻是以 RGB 或 HSB 的方式用的，而不是 CSS HEX，这是非常基本的要求。再甚者你还应该知道你的程序员使用的 IDE 可能不会帮他补全 &lt;code&gt;/255&lt;/code&gt; 这一内容，所以为了让他不再打出无数个 &lt;code&gt;/255&lt;/code&gt; ，你给他的值应该是 &lt;code&gt;R: 0.39&lt;/code&gt;  而不是 &lt;code&gt;R: 100&lt;/code&gt;  。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么作为程序员，你应该能看得懂 &lt;code&gt;#6B4449&lt;/code&gt; 是什么意思，并具有把它转换成 RGB 或 HSB 数值的能力，这样可以保证你在遇到了相对糟糕的设计师的时候，也能完成任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好的设计师应该把程序员培养成设计领域的废人，程序员指定图片名，设计师这边把相应图片导出，名称、尺寸分毫不差，并附带 1x、2x、3x 给 iOS，各种 dpi 给 Android。而程序员这边即便只拿到了 .psd 或 .sketch 文件也能把项目做完。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，无论是程序员、设计师还是 PM，都应该了解大家共同面对的这个平台，依然拿 iOS 举例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF1.png&quot; alt=&quot;UIAlertController&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面这个是 iOS 系统提供的控件 - UIAlertController，这个东西在程序员眼里表现起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let alert = &lt;span class=&quot;built_in&quot;&gt;UIAlertController&lt;/span&gt;(
    title: &lt;span class=&quot;string&quot;&gt;&quot;A Short Title Is Best&quot;&lt;/span&gt;,
    message: &lt;span class=&quot;string&quot;&gt;&quot;A message should be a short, complete sentence.&quot;&lt;/span&gt;,
    preferredStyle: &lt;span class=&quot;built_in&quot;&gt;UIAlertControllerStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.ActionSheet&lt;/span&gt;)

alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Cancel&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Cancel&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Choice One&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Default&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Choice Two&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Default&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以程序员此时需要的信息是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;# UIAlertController&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;title:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;A Short Title Is Best&quot;&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;message:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;A message should be a short, complete sentence.&quot;&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Cancel&quot;&lt;/span&gt; - Cancel
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Choice One&quot;&lt;/span&gt; - Default
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Choice Two&quot;&lt;/span&gt; - Default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就足够了。当然你可以把上面那张图也做出来给程序员预览，防止出错，但是你要明白这个东西是 iOS 系统提供的，UIAlertController 是现成可调用的 API，你要做的是只是提供调用这个 API 需要的参数，而不是做一个一模一样的 UIAlertController，还把图片裁成 1x、2x、3x 以为这个东西是程序员手动做的。如果这个东西真的是程序员手动做的，那么显然你应该把 Cancel、Choice One、Choice Two 这三个东西分开提供图片资源，否则怎么可能会有三个可点击的地方？!&lt;/p&gt;
&lt;p&gt;又或者说某个可点击控件被点击之后的效果，iOS 有自己的 Human Interface Guidelines，Android 有 Google 提供的 Material Design，你只要给 Button 提供里面的 Image 资源就可以了，告诉客户端开发的程序员阴影模糊几像素、向右偏移几像素、向下偏移几像素是极其不专业的行为。&lt;strong&gt;同样的，作为设计师，你可以不懂 UIButton 怎么创建，但是你要搞清楚 “iOS 里面的 Button” 或者 “Android 里面的 Button” 到底是什么，了解你的设计应该以怎么样的形式被融入到程序员的工作中，这才是设计，否则只是美工，更何况连图片资源都不能正常提供，连美工都算不上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似的例子太多太多了……&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;或许这篇文章的标题还可以改成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在这个行当，不做设计师也得懂设计&lt;/li&gt;
&lt;li&gt;在这个行当，不做产品经理也得懂产品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不想吐槽，只想分享一点自己的看法，我觉得真正的专业，不仅是把自己份内的事做好这么简单，因为常常和你合作的人并不能把他份内的事做好。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先来捋一捋思路，关于各个岗位合作打造（移动端）产品的一点想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么只有程序员是不够的&lt;/li&gt;
&lt;li&gt;如何做一个好的非程序员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;声明：&lt;br&gt;本人是程序员，截止到目前，我用的设计都是自己设计的，我用的
    
    </summary>
    
    
      <category term="其他" scheme="/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ViewController 减负记录</title>
    <link href="/2016/04/16/ViewController-%E5%87%8F%E8%B4%9F%E8%AE%B0%E5%BD%95/"/>
    <id>/2016/04/16/ViewController-减负记录/</id>
    <published>2016-04-16T12:58:18.000Z</published>
    <updated>2016-04-16T13:04:30.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;最近在重构一个以前写的老项目，在尝试给之前的 ViewController 减负，尽量抽离代码到其他文件。&lt;br&gt;想记录一些东西，看看以后返回来再看能不能有更好的想法；而现在，可以作为一个检验当前代码是否需要优化的一个标准。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;整合常量&quot;&gt;整合常量&lt;/h3&gt;&lt;p&gt;以前喜欢在 ViewController 的顶部（class 外面）写一些全局变量，这样虽然可以写一次创建的代码，就可以在整个项目的任意地方使用。但是，基本上你不可能只有一个 ViewController，有了这种习惯之后，会让全局变量没有逻辑地分散在不同的代码文件里，不易于管理（甚至可能会出现同一个东西以不同的名字被创建了多次的情况），而且代码可读性会严重降低（因为你看见这个变量的时候，你可能并不知道它是全局的）。&lt;/p&gt;
&lt;p&gt;解决起来其实很简单，我当前这个项目的缩写是 GM，于是我建了一个叫 GMConstants 的 Class，把所有之前的全局变量都放到这里，写成 &lt;code&gt;static let&lt;/code&gt; 的形式。（除非你真的知道这样没问题，否则不建议写 &lt;code&gt;static var&lt;/code&gt;，或创建 GMVariables Class，这样会导致你使用这些量的时候，依然不知道具体这些是什么，因为它们可能被更改过）&lt;/p&gt;
&lt;p&gt;比如之前我设定了我这个 App 中使用的所有的灰色都应该是一样的，我写了一个 gmGreyColor 的常量，使用的时候，你可能并不记得这么一个东西是全局的，并且担心除了灰色，还有什么颜色，是不是还有个 gmBlackColor？甚至你可能写了一个意义相同的 gmGrayColor，仅仅是因为 grey 和 gray 同义。而现在，你的使用方式应该是 &lt;code&gt;GMConstants.greyColor&lt;/code&gt;——一看便知是什么意思，而且按住 cmd 键，鼠标左击 GMConstants 关键词，你还可以看见你到底创建了几个类似这样的颜色。&lt;/p&gt;
&lt;p&gt;当你想写全局变量，或者发现某个局部变量，在不同的地方被多次使用的时候，就该考虑这个问题了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;布尔标记&quot;&gt;布尔标记&lt;/h3&gt;&lt;p&gt;刚刚提到不建议以整合常量的方式来整合变量，不过后续又发现之前会用这样一种方式来处理逻辑：先写一个值为 &lt;code&gt;false&lt;/code&gt; 的布尔变量，以此作为一种标记，后续根据情况来不断地修改该值为  &lt;code&gt;true&lt;/code&gt; 或者 &lt;code&gt;false&lt;/code&gt; ，来判断某些语句是否应该执行。&lt;/p&gt;
&lt;p&gt;虽然目前认为这种方式并不是优雅的写法，因为这样一个布尔标记的作用范围太大了，虽然写代码的时候知道，某种情况 &lt;code&gt;true&lt;/code&gt;，另一种情况 &lt;code&gt;false&lt;/code&gt;，但以后修改的时候，就要求程序员有全局观才能尝试修改或移除这个标记。&lt;/p&gt;
&lt;p&gt;暂时没有想到很好的修改方法，但是认为这种情况下，可以像之前整理 &lt;code&gt;static let&lt;/code&gt; 一样来以 &lt;code&gt;static var&lt;/code&gt; 的形式来整理这些布尔类型的标记，可能取 class 名为 GMMarks。&lt;/p&gt;
&lt;p&gt;另外还可以自定义这些标记的 setter，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; imageSelected:&lt;span class=&quot;keyword&quot;&gt;Bool&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以这样自定义 setter：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
    GMMarks.imageSelected = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;
}
class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;deselectImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
    GMMarks.imageSelected = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语义更清晰易懂&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;UIView_耦合&quot;&gt;UIView 耦合&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view1)
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view2)
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假如说在 ViewController 里面看到上面这样的代码，同时发现 view1、view2、view3 之间就是简单的一层一层叠加而已，那么我们或许可以向之前一样建一个叫做 GMViews 的 class，然后把这三个 view 的创建都放在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;xxView&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(frame frame:CGRect)&lt;/span&gt; -&amp;gt; &lt;span class=&quot;title&quot;&gt;UIView&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一个方法里面，使用时也很简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let xxView = GMViews.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;xxView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: xx)&lt;/span&gt;&lt;/span&gt;
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubView&lt;/span&gt;(xxView)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候一定要注意，之前三个 view 在 ViewController 里面创建时，frame 是根据 self.view 这个 view 来写的，frame.origin 是一个 CGPoint，它表示的是相对于父级 view 的相对位置，而不是相对于你的 App 界面的绝对位置，所以抽离这部分代码的时候，确保你的各个 view 的 frame 写对（在支持横屏的时候，是不是还涉及其他问题）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;抽离方法命名问题&quot;&gt;抽离方法命名问题&lt;/h2&gt;&lt;p&gt;MVC 令人诟病的一点是，以前写在 Controller 里面的业务逻辑很臃肿，现在加个 &lt;code&gt;func&lt;/code&gt; 关键字就抽离到 Model 里面，导致 Controller 不臃肿了，Model 反倒臃肿了。&lt;/p&gt;
&lt;p&gt;所以如果想要从之前臃肿的 ViewController 里面抽离到代码到新的类，一定要注意 Model 的命名问题。  &lt;/p&gt;
&lt;p&gt;比如说我现在要清理缓存，清理缓存这种事情应该说和当前的 ViewController 是没什么耦合性可言的，完全可以把这部分代码剥离出来，那么如果这时候我根据清理的具体内容不同，抽象出了三个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果直接粗暴地把这三个方法填到一个叫做 GMTools 的类里面，把这些方法都加上  &lt;code&gt;class&lt;/code&gt; 关键字，那么以后这个类会越来越杂乱，这和之前没什么分别。&lt;/p&gt;
&lt;p&gt;较好的做法应该是把这个类叫做 GMClear，而且尽量调用方法的时候，让方法体内部的逻辑和现在的这个 App 本身没太大关系，把和现在的 App 有直接关系的部分作为参数，让使用者传参调用。&lt;/p&gt;
&lt;p&gt;这样下来，或许你可以在这个项目结束的时候，拥有几个可能叫 GMClear、GMSave、GMShare 的类，而且这些类里面的方法和你现在这个 App 没有太多直接联系，那么下一个项目用到这些东西，直接把代码文件复制过去就可以了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;最近在重构一个以前写的老项目，在尝试给之前的 ViewController 减负，尽量抽离代码到其他文件。&lt;br&gt;想记录一些东西，看看以后返回来再看能不能有更好的想法；而现在，可以作为一个检验当前代码是否需要优化的一个标准。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>实习求职终结篇</title>
    <link href="/2016/04/15/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E7%BB%88%E7%BB%93%E7%AF%87/"/>
    <id>/2016/04/15/实习求职终结篇/</id>
    <published>2016-04-15T14:01:39.000Z</published>
    <updated>2016-08-23T01:27:28.000Z</updated>
    
    <content type="html">&lt;p&gt;在和腾讯、阿里各通了4次电话之后，翘掉了腾讯的最后一面（因为是在隔壁的城市，而且是群面，心理上有点抗拒），拿到了阿里无线事业部的 offer，个人还是很满意，反过来记录一下整个过程，分享一下。&lt;/p&gt;
&lt;h2 id=&quot;做简历&quot;&gt;做简历&lt;/h2&gt;&lt;p&gt;大概2月底的时候，感觉到各大公司都开始有招聘的苗头了，了解到腾讯是3月底截止内推，其他公司也差不多。然后迅速撰写草稿，用一晚上的时间完成了简历的制作，虽然后来也修改了简历，但是第一版已经确定了 80% 的内容。这里面有一点要提一下，关于如何做简历（制作，不是简历的内容）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我个人的简历是“维护”了4个版本的：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个 txt 或者 rtf 用来放纯文本的信息，这是你的 PDF 版的简历的内容来源。因为无论用 pages 还是 word 还是其他工具来做简历，难免要有格式、图片等等其他元素，会影响到你撰写信息，所以需要有一个纯文本用来撰写信息，以此为数据源来更新你最终简历上的内容。&lt;/li&gt;
&lt;li&gt;一个 pages（或 word 等）文档，这是随时用来修改并且导出 PDF 版简历的。&lt;/li&gt;
&lt;li&gt;PDF 版简历，这个简历的命名要写好，可以写成【简历_iOS开发实习_姓名】，这样任何时候需要简历，都可以直接发过去，命名可以让人一眼看出这是什么文件。&lt;/li&gt;
&lt;li&gt;一个 JPG 版本，虽然正式简历不该用图片，但是万一有机会在微信或者微博上发现有机会和别人私聊拿到工作机会，手机上是不能在微信和微博客户端发 PDF 的，所以这个也要准备好，而且要在清晰度高的同时保证文件不要太大，10M 的图片发出去都费劲。&lt;br&gt;（如果想参考的话，可以&lt;a href=&quot;https://github.com/OpenMarshall/MyResume/raw/master/%E7%AE%80%E5%8E%86_iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0_%E5%BE%90%E5%BC%80%E6%BA%90.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击下载我的简历&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;找内推&quot;&gt;找内推&lt;/h2&gt;&lt;p&gt;在各个公司的内推期间，我拿到了腾讯、阿里、网易、蘑菇街4家的内推（京东也可以拿的，但是他们竟然不招 iOS 开发），而最终给我 offer 的阿里，帮我内推的人我压根就不认识，或许当初没有间接找人内推阿里，我现在连个机会都没有。&lt;/p&gt;
&lt;p&gt;所以想说，只要认真去联系一下，找一找中间人，其实联系上哪家公司的员工都不难。因为觉得自己不认识这家公司的人，就想不走内推流程或者干脆不去应聘，实在太可惜了。&lt;/p&gt;
&lt;h2 id=&quot;电面&quot;&gt;电面&lt;/h2&gt;&lt;p&gt;非常感谢腾讯的师兄，因为他的帮忙，我同时接到了手机 QQ 和微云两个部门的电面，所以按说只有两轮的电面，我接到了4次，涨了不少经验。之前的文章：&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/08/%E8%85%BE%E8%AE%AF-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯 iOS 开发实习电话面试记录（一）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/16/%E8%85%BE%E8%AE%AF-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯 iOS 开发实习电话面试记录（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里这边是手机淘宝部门，一路都很顺利，一面打了7分钟电话，都是简单问题（运气好重要），二面没聊技术（和我个人简历有关），三面是正规的技术面，四面HR是很普通的聊天。之前的文章：&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/19/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里 iOS 开发实习电话面试记录（一）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/29/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里 iOS 开发实习电话面试记录（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里可以给的一点建议是：不要遇到答不出来的问题就一个字都不说，猜也好、临时分析也好，至少展现一点主动分析问题的状态。&lt;/p&gt;
&lt;h2 id=&quot;笔试&quot;&gt;笔试&lt;/h2&gt;&lt;p&gt;这里还是想吐槽一下，这些大公司都有些偷懒，笔试页面一看就是外包项目，感觉是建了一个题库，考试的时候直接从题库随机抽题目。&lt;/p&gt;
&lt;p&gt;笔试非常考验 CS 基础，数据库、操作系统、计算机网络、算法、C++ 的东西会的越多越好（实际上也确实是会的越多越好）。但是给客户端开发实习生同一套题目我实在是不服，有些 Android 题目给我做真是题都没看懂……&lt;/p&gt;
&lt;p&gt;不过趟基础也不是三两天可以搞定的，只能推荐个我个人觉得还不错的&lt;a href=&quot;http://www.nowcoder.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;刷题网站&lt;/a&gt;。还有就是，虽然在线笔试的网站监测作弊的手段并不强，还是劝想作弊的人不要这么干，抛开道德准则不说，万一出事，后果太严重了。&lt;/p&gt;
&lt;h2 id=&quot;寻求更多机会&quot;&gt;寻求更多机会&lt;/h2&gt;&lt;p&gt;虽然我给十多家小公司发了邮件没有收到任何回复，但是认为广投简历、对这些信息敏感一点总是好的。&lt;br&gt;在阿里四面之前，我就直接或间接地通过微博拿到了一家小公司（不便透露名称）的 offer 还有去饿了么做 React Native 的机会。&lt;br&gt;所以，主动一点吧～&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在和腾讯、阿里各通了4次电话之后，翘掉了腾讯的最后一面（因为是在隔壁的城市，而且是群面，心理上有点抗拒），拿到了阿里无线事业部的 offer，个人还是很满意，反过来记录一下整个过程，分享一下。&lt;/p&gt;
&lt;h2 id=&quot;做简历&quot;&gt;做简历&lt;/h2&gt;&lt;p&gt;大概2月底的时候，感觉到
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>扯淡 Method Swizzling</title>
    <link href="/2016/04/06/%E6%89%AF%E6%B7%A1-Method-Swizzling/"/>
    <id>/2016/04/06/扯淡-Method-Swizzling/</id>
    <published>2016-04-06T03:11:29.000Z</published>
    <updated>2016-04-09T15:56:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;&lt;p&gt;关于 Method Swizzling 这个东西，已经有很多高人写了详细的文章来介绍，我就不再班门弄斧，往深了说了。&lt;br&gt;而且不作延伸的话，这项技术本身也没有复杂到要长文论述的地步。&lt;br&gt;本文旨在帮助不熟悉这项技术的人，开始在实际开发过程中，尝试使用它。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;这是个啥&quot;&gt;这是个啥&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;swizz 这个词在英语里面是“欺骗”的意思。&lt;br&gt;Method Swizzling 也叫做“方法调配”、“方法混合”、“方法调和”，&lt;strong&gt;是用来互换两个方法的实现的技巧。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这东西并不常用，比如我们用方法 A 实现了 a 这件事，方法 B 实现了 b 这件事，现在你非要用 A 实现 b，B 实现 a，即便技术上是可行的，你图个啥？回头再换回来你还记得不？再换第三次呢？&lt;/li&gt;
&lt;li&gt;那么什么时候可能需要用到这个东西呢？调试的时候。&lt;br&gt;如果方法 A、B 我都知道怎么实现的，那确实不用换。但是假如方法 A 的实现被隐藏了，那么我是不是可以用方法 B 调用方法 A，再顺便添加点别的功能，然后进行 A、B 实现 swizz。&lt;br&gt;这样再调用方法 A 的时候，就多了一点我们之前顺便添加的功能。&lt;br&gt;有人会说，你这有意思么，你直接调用方法 B 不就得了，为啥还要换？重点在于，方法 A 如何被调用可能不是我们可以决定的啊。或许这个方法已经在无数个地方被调用了无数次，那我想批量替换的话，当然就可以 swizz 了。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;举栗子&quot;&gt;举栗子&lt;/h3&gt;&lt;p&gt;比如说，在某个项目中，NSArray 实例的下面这个方法被调用了 N 多次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containsObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我想调试一下，看看如果这个方法返回 true，即数组包含我们传入的元素的时候，这个元素在数据的什么位置（index）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;indexOfObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然直接调用上面这个方法就可以知道 index，但是 &lt;code&gt;containsObject&lt;/code&gt; 被使用了太多次，Xcode 现在又不支持 Swift 重构，懒得改了。那就写个新方法，给原方法加个可以输出 index 的功能，再用 swizz 替换一下两个方法的实现吧。&lt;/p&gt;
&lt;p&gt;这里我贴了完整的一个 demo 的代码，你可以直接粘到 Xcode 里面运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()

        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;(array: [&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Method&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Swizzling&quot;&lt;/span&gt;])

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 之前-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;

        &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.swizz() &lt;span class=&quot;comment&quot;&gt;// 方法互换&lt;/span&gt;

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 之后-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// 先输出 index，再 true&lt;/span&gt;

        &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.swizz() &lt;span class=&quot;comment&quot;&gt;// 方法再换回来&lt;/span&gt;

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 两下-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;
    }

}

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSArray&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;comment&quot;&gt;// 用来和默认方法进行替换的方法&lt;/span&gt;
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myContainsObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; {
        &lt;span class=&quot;comment&quot;&gt;// 输出元素的 index，这是默认的原方法不具有的功能&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.myContainsObject(anObject) {
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;index：\\(self.indexOfObject(anObject))&quot;&lt;/span&gt;)
        }
        &lt;span class=&quot;comment&quot;&gt;// 不会产生死循环，因为运行期间，下面的方法已经被替换成了默认的 containsObject&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.myContainsObject(anObject)
    }

    &lt;span class=&quot;comment&quot;&gt;// 用来给不同方法互相替换的方法&lt;/span&gt;
    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swizz&lt;/span&gt;() &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; originalMethod = class_getInstanceMethod(&lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, #selector(containsObject(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;:)))
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; swizzledMethod = class_getInstanceMethod(&lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, #selector(myContainsObject(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;:)))
        method_exchangeImplementations(originalMethod, swizzledMethod)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-7f3a68b6ef76a5af.png&quot; alt=&quot;console&quot;&gt;&lt;br&gt;【注意几点】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这里我先后调用了三次 &lt;code&gt;containsObject&lt;/code&gt; 这个方法，其中第二次，它的内部实现被  &lt;code&gt;myContainsObject&lt;/code&gt; 这个方法的内部实现替换掉了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myContainsObject&lt;/code&gt; 这个方法乍一看是死循环，如果你直接调用它的话，它也确实是死循环。但现在我们是在 RunTime 期间，动态地决定这个方法的内部实现的，在我们调用这个方法，进入它的函数体的时候，它的实现就已经被换掉了，所以在它的内部，你应该把 &lt;code&gt;myContainsObject&lt;/code&gt; 这个词在你的脑子里换成 &lt;code&gt;containsObject&lt;/code&gt;（如果确定此时两个方法确实互换了实现）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;&lt;p&gt;如果我写的这点东西可以帮助你以后的 debug 工作，那么最好。&lt;br&gt;如果你要在实际项目里用它……你要是真能用上也挺厉害。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;&lt;p&gt;关于 Method Swizzling 这个东西，已经有很多高人写了详细的文章来介绍，我就不再班门弄斧，往深了说了。&lt;br&gt;而且不作延伸的话，这项技术本身也没有复杂到要长文论述的地步。&lt;br&gt;本文旨在帮助不熟悉这项技术的人，开始
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里 iOS 开发实习电话面试记录（二）</title>
    <link href="/2016/03/29/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>/2016/03/29/阿里-iOS-开发实习电话面试记录（二）/</id>
    <published>2016-03-29T06:58:00.000Z</published>
    <updated>2016-04-09T15:57:20.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 客户端开发的三面。&lt;/p&gt;
&lt;p&gt;这次的面试官，一听他说话，年纪就不小了，感觉差不多也是个全栈。他问的 iOS 相关的问题我 90% 都答上来了，提到操作系统、计算机网络、算法之类的，我直说因为长期不投入实用，都忘了，他就说那就不问这方面的了，最后还劝告说，这些更多是方法论的东西，建议我学好，下面是他问了的 iOS 相关的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;（我在简历上写自己独立开发了几个 App）说一下你自己做的那个 App（随便挑了一个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（我大概阐述了产品方向之后，他问我技术上最难的是什么，然后随口提到了要保存图片到相册）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于 iOS 系统相册，有哪些相关方案可以获取？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以前的 AssetsLibrary 和现在的 Photos 框架都知道吗？&lt;br&gt;（我说了关于现在引入 Photos 和 PhotosUI 之后可以获取 LivePhoto 的问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;都熟悉哪些框架，有没有特别了解的？&lt;br&gt;（我说我熟悉 WebKit，然后他就问了我 GCD = =）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（发现我会用 GCD 之后）能不能说一下底层？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（我说我知道点 ARC 相关的底层实现，就说了一通，他很满意，这里要强烈推荐下面这本书）&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-7b1d63a98ab4148d.png&quot; alt=&quot;Objective-C 高级编程&quot;&gt;&lt;br&gt;同类型的问题还有 assign、weak 的区别，ARC 如何实现，编译时、运行时区别，weak 属性的对象在废弃后 指针是如何指向 nil 的……&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平时了解一些架构吗？&lt;br&gt;（我说我知道 MVC、MVVM。其他的光知道没用过，不敢拿出来装B）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;说一下 MVVM&lt;br&gt;（泪奔，难得在面试的时候能碰上自己很熟悉的，推荐不熟悉的看看最近挺火的文章&lt;a href=&quot;https://realm.io/cn/news/doios-natasha-murashev-protocol-oriented-mvvm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《面向协议的 MVVM 架构介绍》&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知道 KVO、KVC 吗？&lt;br&gt;（虽然这个东西大家都在用，但是查一下还是能查出来一些自己不知道的，心里没底的，建议现在就去 Google 一下）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你平时做 App 之后，有什么推广途径？&lt;br&gt;（其中我提到了一些推广平台，国内的有 36Kr 的 &lt;a href=&quot;http://next.36kr.com/posts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NEXT&lt;/a&gt;、爱范儿的 &lt;a href=&quot;http://mindstore.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MindStore&lt;/a&gt; 和 &lt;a href=&quot;https://itunes.apple.com/app/id966457637&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AppSo&lt;/a&gt;，国外的有 &lt;a href=&quot;https://www.producthunt.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProductHunt&lt;/a&gt;，好像他在听的时候还在一边拿笔记，人家也还在学习啊~）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 客户端开发的三面。&lt;/p&gt;
&lt;p&gt;这次的面试官，一听他说话，年纪就不小了，感觉差不多也是个全栈。他问的 iOS 相关的问题我 90% 都答上来了，提到操作系统、计算机网络、算法之类的，我直说因为长期不投入实用，都忘了，他就说那就不问这方面的了，最后还劝告说，这些更多
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift Print 高级用法</title>
    <link href="/2016/03/27/Swift-Print-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>/2016/03/27/Swift-Print-高级用法/</id>
    <published>2016-03-27T06:59:00.000Z</published>
    <updated>2016-04-09T15:57:44.000Z</updated>
    
    <content type="html">&lt;p&gt;这个东西不是我写的，&lt;a href=&quot;http://stackoverflow.com/questions/30865233/print-without-newline-in-swift-2-0/30865283#30865283&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;出自 StackOverFlow&lt;/a&gt;，但我觉得实在是写得太好了，于是截取了该部分分享出来，感谢原作者。&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-36ae85cb732a2b30.png&quot; alt=&quot;StackOverFlow&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个东西不是我写的，&lt;a href=&quot;http://stackoverflow.com/questions/30865233/print-without-newline-in-swift-2-0/30865283#30865283&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里 iOS 开发实习电话面试记录（一）</title>
    <link href="/2016/03/19/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>/2016/03/19/阿里-iOS-开发实习电话面试记录（一）/</id>
    <published>2016-03-19T06:59:54.000Z</published>
    <updated>2016-04-09T07:12:13.000Z</updated>
    
    <content type="html">&lt;p&gt;写这篇文章的时候我已经接到阿里的两个电话了，只是因为可能他们安排的面试轮次比较多，所以打一次电话并没能说太多东西，攒了两次一起写。&lt;/p&gt;
&lt;h2 id=&quot;第一轮&quot;&gt;第一轮&lt;/h2&gt;&lt;p&gt;打了不到十分钟就结束了。都是问的所谓必考的那些基本题目：循环引用、检测内存泄露、TableView滑动卡顿解决方案等等，因为之前已经被腾讯虐了一波，这次对答如流，他就直说给过，等下一次电话。&lt;/p&gt;
&lt;h2 id=&quot;第二轮&quot;&gt;第二轮&lt;/h2&gt;&lt;p&gt;这个打了二十分钟，一个技术题没问。可能跟我简历写的有关系，我说独立做了几个 App，然后他让我自我介绍之后，问我是不是整个产品全部是独立做的，我说是，他就只问这个层面的东西了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么想到要做这些东西的，idea 的来源？&lt;/li&gt;
&lt;li&gt;身边的人都在用吗？&lt;/li&gt;
&lt;li&gt;App 更新情况怎么样，通过什么来更新，怎么了解自己做的东西的缺陷？&lt;/li&gt;
&lt;li&gt;知不知道平时自己的东西活跃度怎么样，每天有多少人用？&lt;/li&gt;
&lt;li&gt;怎么推广自己的东西，推广渠道？除了你已经采用的这些渠道，再想点别的？&lt;/li&gt;
&lt;li&gt;你看淘宝客户端一般都是全五星评论，你怎么来让你的 App 在 AppStore 呈现好的评分？&lt;/li&gt;
&lt;li&gt;（之前谈到有些 App 因为产品思路不对的问题，做失败了）这些放弃了的 App 是哪里有问题？&lt;/li&gt;
&lt;li&gt;如果一定要拯救一下这些 App，你该怎么更新？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本就是这些问题，最后说我可以问他一个问题，我就问了一下招聘流程，然后他说每年都有小的变动，目前我也只能保证电话畅通了……&lt;/p&gt;
&lt;p&gt;目测后面的人要猛问技术问题了，Not Afraid。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的时候我已经接到阿里的两个电话了，只是因为可能他们安排的面试轮次比较多，所以打一次电话并没能说太多东西，攒了两次一起写。&lt;/p&gt;
&lt;h2 id=&quot;第一轮&quot;&gt;第一轮&lt;/h2&gt;&lt;p&gt;打了不到十分钟就结束了。都是问的所谓必考的那些基本题目：循环引用、检测内存泄露、Tab
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>腾讯 iOS 开发实习电话面试记录（二）</title>
    <link href="/2016/03/16/%E8%85%BE%E8%AE%AF-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>/2016/03/16/腾讯-iOS-开发实习电话面试记录（二）/</id>
    <published>2016-03-16T07:04:28.000Z</published>
    <updated>2016-04-09T07:12:51.000Z</updated>
    
    <content type="html">&lt;p&gt;继上一篇文章&lt;a href=&quot;http://www.jianshu.com/p/8e8871a9677a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【面试】腾讯 iOS 开发实习电话面试记录（一）&lt;/a&gt;后，又接到了第二个电话，继续记录。根据回忆写的，问题先后可能不对。&lt;/p&gt;
&lt;p&gt;（一开始让我自我介绍一下，这一介绍，就说了我基本在用 Swift 而不是 OC 写正式项目，然后他就开始偏重 Swift 来问，也不知道是照顾我，还是怕我撒谎）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;说一下 C/C++ 里面变量定义和声明的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OC 里面的 property 有没有像 Swift 里面一样的 public 和 private 之分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我看你简历里面说你写过超过5万行 Swift，你怎么知道你写过 5 万行？&lt;br&gt;（我说可以通过 Terminal 来统计我的项目文件夹里面任意后缀文件的行数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你这个5万行，包括第三方 API 吗？&lt;br&gt;（我说不包括，不过只要他问 Swift 少问 OC，我还是有信心）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你说一下你对 Swift 这门语言的理解，有什么和 C、C++ 或 OC 不同的地方？&lt;br&gt;（我说了关于 protocol 和 extension 相关的东西，还有关于 OC 里面的 NSString 浅复制，现在 Swift 对 String 类型是深复制，以及 Swift 对这个值拷贝的优化的问题……会的东西还是要多说）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平时你对你上架的这些产品是怎么监测崩溃情况的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平时怎么检测内存泄露，有什么解决方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TableView 滑动卡顿有什么优化方案&lt;br&gt;（这个因为刚好在面试之前还准备了一下，噼里啪啦说了好多，可能还说了点面试官不知道的东西。然后他说你怎么知道这些东西的，平时都在用吗，我说都是在网上看的，因为平时没有做过非常复杂的 Cell，所以实际应用起来了的优化手段并不多）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;说一下 HTTP 协议&lt;br&gt;（我说不会，就简单说了下 http 和 https 的区别，和 iOS 9 开始引导访问 https 的问题，大家可以背一下这一段：&lt;strong&gt;【为了强制增强数据访问安全， iOS9 默认会把所有从&lt;code&gt;NSURLConnection&lt;/code&gt; 、 &lt;code&gt;CFURL&lt;/code&gt; 、 &lt;code&gt;NSURLSession&lt;/code&gt;发出的 HTTP 请求，都改为 HTTPS 请求：iOS9.x-SDK编译时，默认会让所有从&lt;code&gt;NSURLConnection&lt;/code&gt; 、 &lt;code&gt;CFURL&lt;/code&gt; 、 &lt;code&gt;NSURLSession&lt;/code&gt;发出的 HTTP 请求统一采用 TLS 1.2（SSL 3.1） 协议。】&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;说一下你最复杂的一个项目的技术内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你所有项目都是你独立开发完成的吗，包括切图、UI&lt;br&gt;（我说是，不过他也没问我 Photoshop，就此作罢）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;说一下不同版本 iPhone 的分辨率&lt;br&gt;（我说我没背下来那个 320*568 什么的分辨率，但我知道硬件屏幕上 dot 的数量和软件屏幕 pixel 数量的关系，而且很特殊的一点是，虽然 iPhone 3GS 对应的是 1x，iPhone 4S 开始对应 2x，但是 iPhone 6+ 对应的所谓 3x 实际上是 1：2.6几，Apple 帮我们做了把 3x 的图做成 2.6x 的这个工作）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你平时是怎么做技术积累的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;好像电话面试就此结束了，下次面试是面试官来本地走校招流程，然后之前打过电话、简历评级够好的，现场面试的时候会比较容易给 offer。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;继上一篇文章&lt;a href=&quot;http://www.jianshu.com/p/8e8871a9677a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【面试】腾讯 iOS 开发实习电话面试记录（一）&lt;/a&gt;后，又接到了第二个电话，继续记录。根据回忆写的，
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Xd 简明教程 &lt;对比 Sketch&gt;</title>
    <link href="/2016/03/16/Adobe-Xd-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B-%E5%AF%B9%E6%AF%94-Sketch/"/>
    <id>/2016/03/16/Adobe-Xd-简明教程-对比-Sketch/</id>
    <published>2016-03-16T07:02:32.000Z</published>
    <updated>2016-04-09T16:04:59.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;写在前面&quot;&gt;写在前面&lt;/h1&gt;&lt;p&gt;本人在学了一年半平面设计之后（苦于不会画画，只会用软件，没做出个啥东西来），转做的 iOS 开发，算是能写点新手教程，如果您是职业设计师，就别对这篇文章抱太大希望啦。如果你是不会做 UI 的程序员（做 iOS 开发的最好），希望你能有所收获。&lt;/p&gt;
&lt;p&gt;如果你还没装上 Adobe Xd，鉴于现在的 Xd 预览版并不收费，而国内的网络环境又实在不利于我等从 Adobe 官网装那个 Creative Cloud Desktop，我传了一份到&lt;a href=&quot;http://yun.baidu.com/share/link?shareid=3274616498&amp;amp;uk=2097307015&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度盘&lt;/a&gt;，戳链接下载吧。如果用不了的话，里面还有一份 Creative Cloud Installer，装上 Creative Cloud Desktop 之后，可以在线安装 Xd。Sketch 是收费软件，就不给地址了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-e6dbe297c846ad7b.png&quot; alt=&quot;这阵容！&quot;&gt;&lt;/p&gt;
&lt;p&gt;在那个没有 Sketch 的年代，Photoshop 作为图像处理软件之王，横行了很久。Sketch 出现之后呢，虽然 Photoshop 依然在横行，但是在 UI 这个领域，至少被 Sketch 冲击地不轻。而 Photoshop 有自己的产品定位，就是做综合功能最强大的 CG 软件（实际上它也确实做到了），不能为了 Sketch 而改掉自己。&lt;strong&gt;等了好久终于等到今天！Adobe 出了一款和 Sketch 定位一模一样的产品 —— Adobe Xd！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;基础&quot;&gt;基础&lt;/h1&gt;&lt;p&gt;如果您已经会用 Sketch 的话，那是最好，如果是不会做 UI 的程序员的话……快去学一下噻（也只能凑合着看啦）&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-907915cdb210cd36.png&quot; alt=&quot;Sketch &amp;amp; Xd&quot;&gt;&lt;br&gt;如图，左边是 Sketch，右边是 Xd，我分别加入了一个初始的 iPhone 6 大小的 Artboard，别说两边界面基本一样，就连用词都没差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-cc71589e434133e5.png&quot; alt=&quot;Sketch Insert&quot;&gt;&lt;br&gt;Sketch 把插入新元素这个功能放到了 Insert 里面，平时使用基本都是用快捷键的，虽然 Xd 也支持用快捷键来调用这些工具，但是默认左边还有个边栏一直放在这，和 Photoshop 如出一辙，要知道 Xd 的工具比 Photoshop 少的不是一点半点啊，个人感觉这个栏有点鸡肋。&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-84745362c36c3019.png&quot; alt=&quot;Xd 左栏&quot;&gt;&lt;br&gt;而 Sketch 那个丰富的顶部工具栏，在 Xd 里面被分拆了。如 Union、Subtract 等布尔运算，被放到了右侧栏，Mask、Group 等功能，放到了软件的顶部菜单栏里面，这使得 Xd 看起来更简洁一些。不过无所谓，在两个软件里，这些功能都可以用快捷键使用。&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-c2984ebd38dab1b4.png&quot; alt=&quot;Sketch 顶部工具栏&quot;&gt;&lt;br&gt;那么 Xd 的顶部放了什么呢&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-ae4cceed563422d2.png&quot; alt=&quot;Xd Prototype&quot;&gt;&lt;br&gt;通过这个入口，加入了做原型的功能！一看就明了，有木有！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-a54c9d717608162a.png&quot; alt=&quot;Xd Prototype&quot;&gt;&lt;br&gt;如果你是做 iOS 开发的，这些 Segue、Easing、Duration、TARGET 的用词，不能再熟悉了，对开发人员不能再友好。&lt;/p&gt;
&lt;p&gt;回到 Xd 的 Design 这个地方，我发现缺少了 Sketch 左边那个图层管理的列表，还是有些别扭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-6390d788d164d403.png&quot; alt=&quot;一个较为复杂的 Sketch 项目&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如对于上面这个界面，如果没有左边这个管理界面的话，而如果这个东西又是别人做的，我必须要逐个点击才知道谁和谁是一组的，就很麻烦。而且在 Xd 里面，不导出，你是不知道某一个图层的名字的。&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-76e65022be7f405a.png&quot; alt=&quot;Xd Export&quot;&gt;&lt;br&gt;比如这么一个圆形，虽然导出的时候我可以更改它的命名，但是如果我有20个不同的圆，我可能会希望先全部命名好，再批量导出。&lt;/p&gt;
&lt;p&gt;不过在导出的时候，除了文件命名这个事情之外，有一个地方 Xd 做的非常棒，那就是自动生成 1x、2x、3x 等不同尺寸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-28f74ff40fd51eb1.png&quot; alt=&quot;Xd Export&quot;&gt;&lt;br&gt;虽然在 Sketch 里面我们可以给每一个图层加一个 Slice，再给 Slice 设定导出的 1x、2x、3x，还是没有 Xd 的这个解决方案好。针对 Android，Xd 也给了相应的从 ldpi 到 xxxhdpi 的六种规格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-f1227259089e931e.png&quot; alt=&quot;Sketch Slice&quot;&gt;&lt;br&gt;当然也不是说 Sketch 的 Slice 就一无是处，繁琐的东西它当然就自定义程度高一些。比如我们做了一个圆形，要导出一个左半圆和右半圆，那当然用 Slice 要方便的多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除此之外，Sketch 还有安装插件的功能，也凭借先发优势积累了大量的资源和论坛内容。不知道可以做原型的 Xd 和它的好爸爸 Adobe，能不能有机会一举杀入 Sketch 的阵地。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;&lt;p&gt;因为我个人平时不做原型，对这个要求不高，所以现在 Xd 做原型的功能对我来说，简单、够用。&lt;br&gt;假设原型工具占了产品界面设计过程的 20%，那么 Adobe 可能会希望把以前的 PS + Sketch = 80% 的情况，变成 PS + Xd = 100% 吧。&lt;br&gt;就目前工作来说，我会尝试开始用 Xd，遇到个别情况，Xd 不顺手的话，会打开 Sketch，两把刷子一起用，等时间长了，哪个更适合我就有概念了。相当长的一段时间内，我是不会删掉 Sketch 的，就凭那些优质的 Sketch 资源，我也不会删。&lt;br&gt;于个人喜好，虽然我忠爱 Adobe，但垄断总是不好的，Sketch 坚挺住啊！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;写在前面&lt;/h1&gt;&lt;p&gt;本人在学了一年半平面设计之后（苦于不会画画，只会用软件，没做出个啥东西来），转做的 iOS 开发，算是能写点新手教程，如果您是职业设计师，就别对这篇文章抱太大希望啦。如果你是不会做 UI 的程序员（做 iOS 开发的最好），希望
    
    </summary>
    
    
      <category term="设计" scheme="/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
