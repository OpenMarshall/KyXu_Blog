<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KyXu Tech</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2017-08-08T12:10:28.000Z</updated>
  <id>/</id>
  
  <author>
    <name>KyXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 iMazing 进行沙盒调试</title>
    <link href="/2017/08/08/%E4%BD%BF%E7%94%A8-iMazing-%E8%BF%9B%E8%A1%8C%E6%B2%99%E7%9B%92%E8%B0%83%E8%AF%95/"/>
    <id>/2017/08/08/使用-iMazing-进行沙盒调试/</id>
    <published>2017-08-08T12:06:33.000Z</published>
    <updated>2017-08-08T12:10:28.000Z</updated>
    
    <content type="html">&lt;p&gt;当开发项目有可能进行图片的缓存、清理操作时，我们可能会需要&lt;strong&gt;手动去 app 的沙盒里面删除、替换一些内容&lt;/strong&gt;来进行测试，但是通过代码去目录下查找文件可能不是很方便，也不够直观，这里提供一个方法来方便这个调试过程，使用工具：&lt;strong&gt;&lt;a href=&quot;https://imazing.com/zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iMazing&lt;/a&gt; + Chrome&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 iMazing 软件，通过 WiFi 或者 USB 将 iOS 设备连接到电脑之后，可以看到如下这样的界面。&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1ficknrbc20j30yg0kwwgx.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果你的 app 是自己构建到设备，而不是通过 App Store 下载的，那么除了 &lt;strong&gt;文稿&lt;/strong&gt; 文件夹以外，应该还可以看见 &lt;strong&gt;开发者&lt;/strong&gt; 文件夹，而其中的&lt;br&gt; &lt;strong&gt;Documents&lt;/strong&gt; 目录下会有一些你自己通过各种各样的方式进行存储的内容，点开其中某一个目录，可能会发现是这样：&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1ficknsmcppj309d0l3tb2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;走到这一步，就说明你已经定位到了你缓存过的内容，但是这里发现了一个问题：&lt;strong&gt;除了 .mp4 和 .sqlite 之外，我发现很多其他内容没有文件后缀，没办法直接进行预览&lt;/strong&gt;。解决方法：首先把整个文件夹拷贝到本地（iMazing 软件里面的“拷贝至设备”按钮），然后将整个文件夹拖拽到 Chrome 里面，像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1ficknvyfjjj30yg0gzwl6.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后你就可以通过 Chrome 强大的文件查看功能，直接查看这里面的视频、JSON、图片文件，甚至 macOS 无法直接预览的 webp 格式图片都可以直接查看，然后按文件名在 iMazing 里面找到源文件进行删改再回到 Xcode 进行测试即可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;当开发项目有可能进行图片的缓存、清理操作时，我们可能会需要&lt;strong&gt;手动去 app 的沙盒里面删除、替换一些内容&lt;/strong&gt;来进行测试，但是通过代码去目录下查找文件可能不是很方便，也不够直观，这里提供一个方法来方便这个调试过程，使用工具：&lt;strong&gt;&lt;a h
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10.3 如何更换 app 图标</title>
    <link href="/2017/03/30/iOS-10-3-%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2-app-%E5%9B%BE%E6%A0%87/"/>
    <id>/2017/03/30/iOS-10-3-如何更换-app-图标/</id>
    <published>2017-03-29T16:15:57.000Z</published>
    <updated>2017-03-30T16:20:55.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 10.3 开放了更换 app 图标的 API，核心方法是下面这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAlternateIconName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; alternateIconName: String?, 
    completionHandler: &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;params&quot;&gt;(Error?)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;)? = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是&lt;a href=&quot;https://developer.apple.com/reference/uikit/uiapplication/2806818-setalternateiconname#parameters&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;，但是你还需要在 info.plist 里面填一些东西才能让它起作用，&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249-SW14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这部分官方注释内容在这里&lt;/a&gt;。&lt;br&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tNbRwgy1fe5bqm96j9j30yg0ab41z.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但 info.plist 如何填写这部分读起来还是有些晦涩，一时可能搞不清楚如何操作，下面做个示范。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNc79gy1fe5brg4s0rj30xx0aydh3.jpg&quot; alt=&quot;Assets.xcassets&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tKfTcgy1fe5brrc6jdj30nq0exwhw.jpg&quot; alt=&quot;info.plist&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;CFBundleIcons&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;CFBundleAlternateIcons&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;blackBgColor&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;CFBundleIconFiles&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;blackBgColor&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;UIPrerenderedIcon&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;false&lt;/span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;CFBundlePrimaryIcon&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;CFBundleIconFiles&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;AppIcon60x60&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dict&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如图，&lt;code&gt;Primary Icon&lt;/code&gt; 字段写为 &lt;code&gt;AppIcon60x60&lt;/code&gt; 是因为这里 xcassets 里面我只导入了 60pt@2x 和 60pt@3x 的图片资源，这里选为 60 是因为对于 iPhone，60pt 的图片资源图标所需最高质量，更低分辨率的版本系统会自动压缩以展示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;blackBgColor&lt;/code&gt; 是我的用于替换原生图标的图片资源。文件名需要和 info.plist 中保持一致（注意 info.plist 中用到了两次 “blackBgColor”），同时这也是你在代码中设置图标时，需要给 API 传入的参数。同样是 60pt@2x 和 60pt@3x 的图片资源，文件不通过 Assets.xcassets 添加进来，而是直接放到目录中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你需要支持 iPad，建议这里使用 83.5pt（iPad Pro）的图片资源。&lt;/strong&gt;另外还有些其他关于在 iPad 上替换图标的注意事项，&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249-SW14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在这里有说明&lt;/a&gt;，注意我们这里在 info.plist 里面所用的 key 是&lt;code&gt; CFBundleIcons&lt;/code&gt;，还有另外一个 key 是 &lt;code&gt;CFBundleIcons~ipad&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;替换图标部分的代码就超级简单了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()
    }

    &lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeAppIcon&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; sender: Any)&lt;/span&gt;&lt;/span&gt; {

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;UIApplication&lt;/span&gt;.shared.supportsAlternateIcons {
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;you can change this app&#39;s icon&quot;&lt;/span&gt;)
        }&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;you cannot change this app&#39;s icon&quot;&lt;/span&gt;)
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;
        }

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;type&quot;&gt;UIApplication&lt;/span&gt;.shared.alternateIconName {
            &lt;span class=&quot;comment&quot;&gt;// CHANGE TO PRIMARY ICON&lt;/span&gt;
            &lt;span class=&quot;type&quot;&gt;UIApplication&lt;/span&gt;.shared.setAlternateIconName(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) { (err:&lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt;?) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;set icon error：&lt;span class=&quot;subst&quot;&gt;\(String(describing: err)&lt;/span&gt;)&quot;&lt;/span&gt;)
            }
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;the alternate icon&#39;s name is &lt;span class=&quot;subst&quot;&gt;\(name)&lt;/span&gt;&quot;&lt;/span&gt;)
        }&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;comment&quot;&gt;// CHANGE TO ALTERNATE ICON&lt;/span&gt;
            &lt;span class=&quot;type&quot;&gt;UIApplication&lt;/span&gt;.shared.setAlternateIconName(&lt;span class=&quot;string&quot;&gt;&quot;blackBgColor&quot;&lt;/span&gt;) { (err:&lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt;?) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;set icon error：&lt;span class=&quot;subst&quot;&gt;\(String(describing: err)&lt;/span&gt;)&quot;&lt;/span&gt;)
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenMarshall/AlternateIconsSample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是上述所有内容的完整 demo 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tKfTcgy1fe5bs3le2cj30ku11275a.jpg&quot; alt=&quot;screentshot0&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tKfTcgy1fe5bs8uum2j30ku112t9o.jpg&quot; alt=&quot;screentshot1&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 10.3 开放了更换 app 图标的 API，核心方法是下面这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAlternat
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 xcarchive 到分发的 ipa</title>
    <link href="/2017/03/10/%E4%BB%8E-xcarchive-%E5%88%B0%E5%88%86%E5%8F%91%E7%9A%84-ipa/"/>
    <id>/2017/03/10/从-xcarchive-到分发的-ipa/</id>
    <published>2017-03-10T07:48:53.000Z</published>
    <updated>2017-03-10T07:49:11.000Z</updated>
    
    <content type="html">&lt;p&gt;写这篇文章的起因是要更新 app ，然而上传 ipa 文件到 iTunes Connect 时发现体积巨大，是 App Store 显示的体积的好几倍，于是仔细研究了一下，各种体积的文件都是些什么。&lt;/p&gt;
&lt;h2 id=&quot;各格式简要说明&quot;&gt;各格式简要说明&lt;/h2&gt;&lt;p&gt;.xcarchive&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&lt;span class=&quot;ruby&quot;&gt; &lt;span class=&quot;constant&quot;&gt;Xcode&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Archive&lt;/span&gt;
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 由 &lt;span class=&quot;constant&quot;&gt;Xcode&lt;/span&gt; 进行 &lt;span class=&quot;constant&quot;&gt;Archive&lt;/span&gt; 操作产生的结果，出现在 &lt;span class=&quot;constant&quot;&gt;Xcode&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Organizer&lt;/span&gt; 中
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 主要包含 .dSYM .app .dylib（针对 &lt;span class=&quot;constant&quot;&gt;Swift&lt;/span&gt;）
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 用于生成 .ipa 文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNc79ly1fc4b4zgadvj30n80eagmt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;.ipa（Xcode 产出）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&lt;span class=&quot;ruby&quot;&gt; iPhone &lt;span class=&quot;constant&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Archive&lt;/span&gt;
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 主要包含 .app .dylib（针对 &lt;span class=&quot;constant&quot;&gt;Swift&lt;/span&gt;）
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 最终从本地 upload 到 iTunes &lt;span class=&quot;constant&quot;&gt;Connect&lt;/span&gt; 的文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.ipa（iTunes 下载）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&lt;span class=&quot;ruby&quot;&gt; iPhone &lt;span class=&quot;constant&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Archive&lt;/span&gt;
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 主要包含 .app iTunesMetadata iTunesArtwork
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; iTunes 用于管理应用软件安装包的形式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.app&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&lt;span class=&quot;ruby&quot;&gt; &lt;span class=&quot;constant&quot;&gt;Applicaiton&lt;/span&gt;
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 主要包含图片、语言文件等资源，以及动态库和 &lt;span class=&quot;constant&quot;&gt;Unix&lt;/span&gt; 可执行文件
&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; 安装到 iOS 设备的文件的格式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;从_xcarchive_到_ipa&quot;&gt;从 xcarchive 到 ipa&lt;/h2&gt;&lt;p&gt;在进行 Archive 操作之前，我们就可以在 Xcode 导航栏的 Products 目录中看到 .app 文件，extension target 对应的是 .appex 文件，所以归档出 .xcarchive 并不是一个非常复杂的操作，只需要编译、链接、简单的签名，如果是 Swift 项目的话还需要拷贝一下标准库。&lt;/p&gt;
&lt;p&gt;我们查看 .xcarchive 里面的内容是通过“显示包内容”看见的，而 .ipa 则需要像 .zip 文件一样解压，那么也可以理解为什么打包出 ipa 文件相对耗时了，尤其是 Swift 项目，不光要进行压缩操作，要 processing，一堆原生动态库加上第三方 framework 还要轮着等着签名。&lt;br&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tNc79ly1fc4aqn10yrj305204oq36.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;这些保证了 ipa 文件不能被模拟器装上（没有 x86 架构），只能被 iOS 设备安装，你买的应用程序发给别人，别人并不能直接装上。从兔兔助手等平台安装的盗版软件一定是被重新签名过的。&lt;br&gt;（由于 ipa 文件上传到 iTunes Connect 之后，还会被重新处理，所以个人尚且不知道后续的处理过程还进行过怎样的签名工作）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以 ipa 文件才可以作为加密文件放在软件商店，xcarchive 不可以。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;从_Xcode_产出的_ipa_到用户下载的_ipa&quot;&gt;从 Xcode 产出的 ipa 到用户下载的 ipa&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006tNc79ly1fc4bf03jhoj307e01mmx5.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;如图是我开发的一款软件打包过程的各个状态，可以看到压缩状态的 ipa 文件是体积最小的。如果将 ipa 文件解压成文件夹，它的体积会和 xcarchive 文件很接近，因为它内部包含了比它本身还要大的整个 .app 包。&lt;br&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tNc79ly1fc4c3yvidyj30lc0aqgmw.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后我分别通过 AppStore 和 TestFlight 安装了我上传的软件，结果都只占用了大约 15M 的空间。&lt;br&gt;前面提到，下载到设备的是 ipa，安装到设备的是 app。但看图，会发现 TestFlight 页面展示的体积和另外三张图相去甚远，30M+。仔细分析下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iPhone 5S 推出之后，iOS 设备指令集从 armv6、armv7、armv7s 一路干到了 arm64，这么些个不同的设备安装到本地的文件肯定不一样吧&lt;/li&gt;
&lt;li&gt;同一设备不同系统，安装的文件也不一样吧&lt;/li&gt;
&lt;li&gt;Xcode 一次只产出一个 ipa，但是考虑到这款软件支持的系统版本数量和设备种类数量，可能最终几十种不同的 iOS 环境（自造词，系统版本或设备型号不同都算环境不同），从同一个 AppStore 页面，下载了几十个不同的 ipa 文件&lt;/li&gt;
&lt;li&gt;尝试发布过 app 的开发者都知道，上传 ipa 文件完成之后，还要等待一段时间，才能在 iTunes Connect 页面看见一个“构建版本”。虽然不知道这个“构建版本”在 Apple 的服务器里面具体都有哪些东西，但至少应该包含一大堆的 ipa 文件，分别指定了对应什么系统版本、什么设备型号&lt;/li&gt;
&lt;li&gt;在这个过程中 ipa 文件的体积发生了很大变化，&lt;a href=&quot;https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;App Thining&lt;/a&gt; 也发生在这个过程中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此可以看出，&lt;strong&gt;AppStore 页面显示的体积应该是预估的应用安装到设备的体积，而不是你下载这款软件所耗费的流量。&lt;/strong&gt;这也解释了我之前尝试用剩 1G 存储的 iPad 去装一个 AppStore 显示 大小不到 1G 的游戏，为什么会装不上，因为下载到 iPad 的文件实际可能大于 1G。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TestFlight 里面显示的 30M+，&lt;/strong&gt;肯定是经过 iTunes Connect 处理过的 ipa，但考虑到 .ipa 文件并不会比安装到设备的 .app 包体积更小，个人认为这&lt;strong&gt;是解压过后的 ipa 文件的体积。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的_app_是如何一步一步变小的&quot;&gt;我的 app 是如何一步一步变小的&lt;/h2&gt;&lt;p&gt;未处理的 .app - 85.6 M&lt;br&gt;&lt;strong&gt;（加入动态库、.dSYM 等）&lt;/strong&gt;&lt;br&gt;xcarchive - 167.7 M&lt;br&gt;未处理的 ipa 文件夹 - 172 M&lt;br&gt;&lt;strong&gt;（经过类似 zip 压缩）&lt;/strong&gt;&lt;br&gt;未处理的 .ipa - 70.8 M&lt;strong&gt;（开发者感受到的体积）&lt;/strong&gt;&lt;br&gt;（个人推测）处理后的 ipa 文件夹- 约 30M&lt;strong&gt;（用户下载需要耗费的流量）&lt;/strong&gt;&lt;br&gt;处理后的 .app - 约 15M&lt;strong&gt;（最终占用用户设备体积）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;备注&quot;&gt;备注&lt;/h2&gt;&lt;p&gt;App Thining 包含 Slicing、Bitcode 和 On-Demand Resources，其中 Slicing 是默认启用、无法关闭的，但只在 iOS 9.0.2 之后有效，后面两个选项在 Xcode 中默认开启，可以手动关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是 Xcode 产物体积与用户下载到设备中的软件体积差距较大的主要原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;a href=&quot;http://www.appcoda.com.tw/app-thinning/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初探 iOS 9 的 App 瘦身功能&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的起因是要更新 app ，然而上传 ipa 文件到 iTunes Connect 时发现体积巨大，是 App Store 显示的体积的好几倍，于是仔细研究了一下，各种体积的文件都是些什么。&lt;/p&gt;
&lt;h2 id=&quot;各格式简要说明&quot;&gt;各格式简要说明&lt;/h2&gt;&lt;p&gt;.
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SnapKit 是怎样炼成的</title>
    <link href="/2016/12/30/SnapKit-%E6%98%AF%E6%80%8E%E6%A0%B7%E7%82%BC%E6%88%90%E7%9A%84/"/>
    <id>/2016/12/30/SnapKit-是怎样炼成的/</id>
    <published>2016-12-30T14:41:34.000Z</published>
    <updated>2016-12-30T14:42:12.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;这是对 Swift 布局框架 &lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapKit&lt;/a&gt; 的源码的一点分析，尝试搞清，一个好的布局框架，背后都做了些什么。&lt;/p&gt;
&lt;h1 id=&quot;介绍_SnapKit_中的一些类&quot;&gt;介绍 SnapKit 中的一些类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ConstraintView&lt;/strong&gt;&lt;br&gt;等同于 UIView&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintAttributes&lt;/strong&gt;&lt;br&gt;用于构造约束关系的各种元素（上下左右等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintDescription&lt;/strong&gt;&lt;br&gt;包含了包括 ConstraintAttributes 在内的各种与约束有关的元素，一个 ConstraintDescription 实例，就可以提供与一种约束有关的所有内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMaker&lt;/strong&gt;&lt;br&gt;构造约束关系的起点，提供了 &lt;code&gt;makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&amp;gt; Void)&lt;/code&gt; 方法来为程序员提供了描述约束的空间，也可以通过 left right top bottom centerX centerY 等属性，去生成一个 ConstraintMakerExtendable 实例（见下面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMakerExtendable（继承 ConstraintMakerRelatable）&lt;/strong&gt;&lt;br&gt;提供 left right top bottom leading trailing edges size margins 等内容，用以产生一个 ConstraintMakerRelatable 类型的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMakerRelatable&lt;/strong&gt;&lt;br&gt;直接用于构造约束关系，也是常用方法 &lt;code&gt;equalTo(_ other: ConstraintRelatableTarget) -&amp;gt; ConstraintMakerEditable&lt;/code&gt; 与 &lt;code&gt;equalToSuperview&lt;/code&gt; 的来源。核心方法是 &lt;code&gt;relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -&amp;gt; ConstraintMakerEditable&lt;/code&gt;，返回 ConstraintMakerEditable 类型的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMakerEditable（继承 ConstraintMakerPriortizable）&lt;/strong&gt;&lt;br&gt;在设定约束的宽度、高度以及偏移的时候，提供相应的加减乘除方法，返回 ConstraintMakerPriortizable 类型的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMakerPriortizable（继承 ConstraintMakerFinalizable）&lt;/strong&gt;&lt;br&gt;提供方法来设置约束的 priority，返回 ConstraintMakerFinalizable 类型的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConstraintMakerFinalizable&lt;/strong&gt;&lt;br&gt;一个只有一个类型为 ConstraintDescription 的属性的类，正如它的类名，有一个 ConstraintMakerFinalizable 实例，就得到了对于一个约束的完整描述。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;至此，我们已经知道 SnapKit 是靠什么来确定了三个东西：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谁在做约束（ConstraintView）&lt;/li&gt;
&lt;li&gt;怎么做约束（ConstraintMaker）&lt;/li&gt;
&lt;li&gt;约束是什么（ConstraintDescription）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; aView = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;()&lt;/span&gt;
aView.snp.makeConstraints({ make &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    make.width.equalToSuperview&lt;span class=&quot;literal&quot;&gt;()&lt;/span&gt;.dividedBy(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).priority(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们写下这样的语句时，先忽略掉 &lt;code&gt;snp&lt;/code&gt; 是什么不管，里面设定 aView 的宽度为它的父视图的一半的这行约束语句，执行了这样的逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ConstraintMaker 提供 &lt;code&gt;makeConstraints&lt;/code&gt; 方法来让我们写约束的同时，开始维护了一个 ConstraintDescription 数组，叫 &lt;code&gt;descriptions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;make 本身是 ConstraintMaker 类型的&lt;/li&gt;
&lt;li&gt;在我们写下 &lt;code&gt;.width&lt;/code&gt; 时，&lt;code&gt;descriptions&lt;/code&gt; 数组第一次加入内容（&lt;code&gt;self.description&lt;/code&gt;），同时我们用这个内容生成了一个 ConstraintMakerRelatable 实例&lt;/li&gt;
&lt;li&gt;在我们写下 &lt;code&gt;.equalToSuperview()&lt;/code&gt; 时，上一步中的内容（&lt;code&gt;self.description&lt;/code&gt;）继续添加信息，同时我们用它生成了一个 ConstraintMakerEditable 实例&lt;/li&gt;
&lt;li&gt;之后的 &lt;code&gt;.dividedBy(2).priority(100)&lt;/code&gt; 使得之前的 ConstraintMakerEditable 实例变成了一个 ConstraintMakerFinalizable 实例，这个实例的 description 属性的类型是 ConstraintDescription，它包含了我们所描述的全部内容。但由于 ConstraintMakerEditable 本身就继承自 ConstraintMakerFinalizable，所以 &lt;code&gt;.dividedBy(2).priority(100)&lt;/code&gt; 这一部分即便不写，这条语句在语法上也已经完成。&lt;br&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006y8lVagw1fb96s29xlwj30ga0953z6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;做个总结：到这里我们发现 ConstraintMaker 以及和它相关的类，构造了一套 &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSL&lt;/a&gt; 来让我们可以轻松地写出约束语句，而这些语句把信息都放到了一个 ConstraintDescription 实例（&lt;code&gt;self.description&lt;/code&gt;）里面，但我们仍然不知道它是如何以 UIKit 里面的 NSLayoutConstraint 的形式作用的。&lt;/p&gt;
&lt;h1 id=&quot;snp_是什么&quot;&gt;snp 是什么&lt;/h1&gt;&lt;p&gt;SnapKit 里面存在这样一些东西：&lt;br&gt;&lt;code&gt;public protocol ConstraintDSL {}&lt;/code&gt;&lt;br&gt;&lt;code&gt;public protocol ConstraintBasicAttributesDSL : ConstraintDSL {}&lt;/code&gt;&lt;br&gt;&lt;code&gt;public protocol ConstraintAttributesDSL : ConstraintBasicAttributesDSL {}&lt;/code&gt;&lt;br&gt;&lt;code&gt;public struct ConstraintViewDSL: ConstraintAttributesDSL {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面我们知道了 &lt;code&gt;aView&lt;/code&gt; 作为一个 UIView，它同时也就是一个 ConstraintView，ConstraintView 有一个 snp 的属性，这给我们提供了入口来通过 SnapKit 给任意的 UIView 或 AppKit 里面的 NSView 通过  &lt;code&gt;.snp&lt;/code&gt; 这样的语法来写约束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个 snp 属性的类型就是结构体 ConstraintViewDSL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一看就是面向协议的写法，通过一个个的 extension 来给 protocol 添加功能，最后用 struct 实现出来，就有了 snp 这个属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; topView = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; centerView = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;()&lt;/span&gt;
centerView.snp.makeConstraints({ make &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
    make.top.equalTo(topView.snp.bottom).offset(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码展现了 snp 的两个作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;snp 有 left top right bottom edges size 等一大堆属性，这些属性的类型是 ConstraintItem，这是用于构造约束位置关系的&lt;br&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fb96sbpzsyj30hu0i6gnx.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;snp 作为 ConstraintViewDSL，有 &lt;code&gt;prepareConstraints&lt;/code&gt; &lt;code&gt;makeConstraints&lt;/code&gt; &lt;code&gt;remakeConstraints&lt;/code&gt; &lt;code&gt;updateConstraints&lt;/code&gt; &lt;code&gt;removeConstraints&lt;/code&gt; 等函数，我们最常用的是 &lt;code&gt;makeConstraints&lt;/code&gt; ，传入一个 closure，在里面写约束关系。这里要注意，我们使用的 &lt;code&gt;makeConstraints&lt;/code&gt; 方法来源于 ConstraintViewDSL，但真正实现了构造约束的其实是我们上文里面写的 ConstraintMaker 里面的 &lt;code&gt;makeConstraints&lt;/code&gt; 方法，见图：&lt;br&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006y8lVagw1fb96sl1i0tj30kp0amjtb.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;约束是如何作用的&quot;&gt;约束是如何作用的&lt;/h1&gt;&lt;p&gt;到现在我们还是没说，从 snp 到 ConstraintMaker，再到 ConstraintMakerFinalizable 的 description 属性，到底哪里创建了 &lt;strong&gt;NSLayoutConstraint&lt;/strong&gt;，答案其实在之前提过多次的 ConstraintMaker 里面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// public class ConstraintMaker&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeConstraints&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item: LayoutConstraintItem, closure: &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; make: ConstraintMaker)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; maker = &lt;span class=&quot;type&quot;&gt;ConstraintMaker&lt;/span&gt;(item: item)
    closure(maker)
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; constraints: [&lt;span class=&quot;type&quot;&gt;Constraint&lt;/span&gt;] = []
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; description &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; maker.descriptions {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; constraint = description.constraint &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;
        }
        constraints.append(constraint)
    }
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; constraint &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; constraints {
        constraint.activateIfNeeded(updatingExisting: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)
    }
}

&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;updateConstraints&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item: LayoutConstraintItem, closure: &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; make: ConstraintMaker)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) {
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; item.constraints.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.makeConstraints(item: item, closure: closure)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;
    }

    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; maker = &lt;span class=&quot;type&quot;&gt;ConstraintMaker&lt;/span&gt;(item: item)
    closure(maker)
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; constraints: [&lt;span class=&quot;type&quot;&gt;Constraint&lt;/span&gt;] = []
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; description &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; maker.descriptions {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; constraint = description.constraint &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;
        }
        constraints.append(constraint)
    }
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; constraint &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; constraints {
        constraint.activateIfNeeded(updatingExisting: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们传入一个闭包来写约束关系时，这个闭包给叫做 maker 的 ConstraintMaker 实例写入了信息，遍历 maker 的 descriptions 之后（我们之前说一条约束语句最终得到一个 self.description，但往往会有多条约束，所以 ConstraintMakerFinalizable 里面的 self.description，在 ConstraintMaker 里被一个数组维护），我们得到了 Constraint 数组。&lt;br&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006y8lVagw1fb96stfw47j30oy0dmdig.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Constraint 这个类还没有介绍过，不过上面这个核心方法加上以前的内容，已经可以让我们猜出来，约束是怎么写出来的了：&lt;br&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006y8lVagw1fb96t47gtcj308209l3yv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;其他内容补充_1&quot;&gt;其他内容补充 1&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fb96taf2zpj30c1050q3i.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;随便写了两句，展示一下各个方法传入的参数的类型，发现有各种 Target，貌似很复杂，不过点开之后发现是这种景象：&lt;br&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fb96u3rw6tj30dk0763zt.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;说白了就是因为 &lt;code&gt;equalTo:&lt;/code&gt; 这个方法里面能传的参数类型比较多，手动来一个一个限制一下，我们看到 ConstraintRelatableTarget 这里可以放一些原生的可以代表数字的类型，外加四个自定义的 Constraint 类型。其他的 Target 协议也差不多是这种情况。&lt;/p&gt;
&lt;p&gt;个人觉得这种做法还是挺值得学习的。&lt;/p&gt;
&lt;h1 id=&quot;其他内容补充_2&quot;&gt;其他内容补充 2&lt;/h1&gt;&lt;p&gt;SnapKit 里面用来表示位置主体的类其实不是 ConstraintView，而是 &lt;strong&gt;ConstraintItem&lt;/strong&gt;&lt;br&gt;我们管这个“主体”叫 target，一个 target，再加上一个 ConstraintAttributes 实例，就可以组成一个 ConstraintItem。&lt;br&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fb96ubrh7vj30f8072js2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;有 attributes 属性很好理解，因为比如我们去做对齐，可以是 aView 的 top 和 bView 的 bottom 对齐，而不能是 aView 和 bView 对齐。但是为什么 target 的类型是 AnyObject 而不是 ConstraintView，即 UIView 或 NSView 呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 ConstraintViewDSL 里面，target 确实是 ConstraintView 类型，&lt;br&gt;但在 ConstraintLayoutSupportDSL 里面，target 是 ConstraintLayoutSupport 类型，&lt;br&gt;在 ConstraintLayoutGuideDSL 里面，target 是 ConstraintLayoutGuide 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分就不具体解释了，想一探究竟的去看 &lt;a href=&quot;https://github.com/SnapKit/SnapKit/blob/develop/Source/LayoutConstraintItem.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LayoutConstraintItem.swift&lt;/a&gt; 这个文件吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;这是对 Swift 布局框架 &lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapKit&lt;/a&gt; 的源码的一点分析，尝试搞清，一
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用 Carthage 摆脱 Bridging-Header.h</title>
    <link href="/2016/12/15/%E7%94%A8-Carthage-%E6%91%86%E8%84%B1-Bridging-Header-h/"/>
    <id>/2016/12/15/用-Carthage-摆脱-Bridging-Header-h/</id>
    <published>2016-12-15T07:54:05.000Z</published>
    <updated>2016-12-15T07:54:35.000Z</updated>
    
    <content type="html">&lt;p&gt;鉴于现在大部分 iOS 常用库都还是用 OC 实现的，我们常常需要用到一个叫做 &lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bridging-Header.h&lt;/a&gt; 的东西来在 Swift 项目中使用 OC 实现的框架，&lt;strong&gt;当然前提是在这个项目里我们不能或者不想使用 Cocoapods 或 Carthage&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 iOS 8 之后，我们可以使用 &lt;a href=&quot;https://skyline75489.github.io/post/2015-8-14_ios_static_dynamic_framework_learning.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;framework&lt;/a&gt; 了，相比于麻烦地操作一遍一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个 Bridging-Header.h 文件&lt;/li&gt;
&lt;li&gt;在 target（还要注意不能是 project）的 Build Settings 找到 Objective-C Bridging Header 项&lt;/li&gt;
&lt;li&gt;然后在里面填上路径，还要注意一下 绝对/相对 路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我更愿意直接把 xxx.framework 放到项目里，然后使用的时候在顶部写上 &lt;code&gt;import XXX&lt;/code&gt;。如果这个框架是 AFNetworking 的话，我们可以在它的 &lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;releases&lt;/a&gt; 页面下载到 &lt;strong&gt;AFNetworking.framework.zip&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/27c8704388d6f6137d4f672af6f9329e.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;但更多像 &lt;a href=&quot;https://github.com/SVProgressHUD/SVProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVProgressHUD&lt;/a&gt; 这样的框架，你只能找到源码，并没有现成的 framework 文件给你用。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/da901c48d1dbf1d12c5626e9a250f22e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;利用_Carthage_打包_framework&quot;&gt;利用 Carthage 打包 framework&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/64013d4372bd5bd7e8999120be2d7063.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;好在它支持了 Carthage。创建了一个文件夹，里面初始只有一个 cartfile&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/547a33d675aed3289be830eee1a3626c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;cartfile 里面随便写了俩常用框架&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2016/12/15/2f93c7519436e64527f9dd6246efe674.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;在终端执行 &lt;code&gt;carthage update&lt;/code&gt; 之后&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006y8lVagw1fariuwlecgj30mp06g3ze.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;现在我们可以直接把打包好的 framework 文件复制到项目里使用了，以后想用什么框架都可以在这个 cartfile 里面添加，在这个文件夹里取用 framework。&lt;/p&gt;
&lt;p&gt;说白了就是一个利用 Carthage 找 framework 文件的方法。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果你想通过自行编译源码，然后在 Products 文件夹里取用 framework，可能这个文件的架构会有问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/a84e3c3788aa509b1ff9&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/4a9d2be042a49e5befba&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/7180d99521ed7d6e5e01&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于现在大部分 iOS 常用库都还是用 OC 实现的，我们常常需要用到一个叫做 &lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bridging-Header.h&lt;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用泛型简化 instantiateViewController</title>
    <link href="/2016/11/03/%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8C%96-instantiateViewController/"/>
    <id>/2016/11/03/用泛型简化-instantiateViewController/</id>
    <published>2016-11-03T08:36:49.000Z</published>
    <updated>2016-11-03T08:37:28.000Z</updated>
    
    <content type="html">&lt;p&gt;使用 storyboard 的时候，我们经常会写出下面这样的代码，用来跳转到其他页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? EditVC {
    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController?.pushViewController(editVC, animated: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最多改成这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实在是太冗长了，简化第一步，或许我们可以直接将 &lt;code&gt;EditVC&lt;/code&gt; 这个类型字符串化变成  &lt;code&gt;“EditVC”&lt;/code&gt;，代码变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;guard &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(describing: EditVC.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? EditVC &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;嗯，更长了，但是既然 &lt;code&gt;EditVC&lt;/code&gt; 使用了两次，这使得我们有机会把这个过程封装成一个函数，而 &lt;code&gt;EditVC&lt;/code&gt; 是唯一需要传递的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;instantiateVC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vc:UIViewController)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(describing: vc.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; storyboard?.instantiateViewController(withIdentifier: id)
}

&lt;span class=&quot;comment&quot;&gt;// how to use&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(vc: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;()) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;封装之后依然尴尬：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为我们不能确定每次都需要函数返回 &lt;code&gt;EditVC&lt;/code&gt; ，所以只能用 &lt;code&gt;UIViewController&lt;/code&gt; 当做返回值，这使得我们还需要再加上 &lt;code&gt;as? EditVC&lt;/code&gt; 去做类型转换，相当于还是手动使用了两次 &lt;code&gt;EditVC&lt;/code&gt; ，而不是一次&lt;/li&gt;
&lt;li&gt;传入的参数是 &lt;code&gt;EditVC()&lt;/code&gt;  而不是  &lt;code&gt;EditVC&lt;/code&gt; ，看起来丑陋&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一次解决两个问题的答案是：泛型！&lt;/p&gt;
&lt;p&gt;我们在函数中限定泛型 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;UIViewController&lt;/code&gt; ，但 &lt;code&gt;T&lt;/code&gt; 具体是我们的 App 中的哪个子类我们不去管，通过函数的参数来指定 T 的具体类型，随后确定出我们函数的返回值为那个我们指定的 &lt;code&gt;T&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;instantiateVC&lt;/span&gt;&lt;span class=&quot;generics&quot;&gt;&amp;lt;T: UIViewController&amp;gt;&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(type: T.&lt;span class=&quot;keyword&quot;&gt;Type&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;? {
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; id = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(describing: &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; storyboard?.instantiateViewController(withIdentifier: id) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;
    }
}

&lt;span class=&quot;comment&quot;&gt;// how to use&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(type: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;前后对比：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// before&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = storyboard?.instantiateViewController(withIdentifier: &lt;span class=&quot;string&quot;&gt;&quot;EditVC&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }

&lt;span class=&quot;comment&quot;&gt;// after&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = instantiateVC(type: &lt;span class=&quot;type&quot;&gt;EditVC&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;&lt;br&gt;这里我假装这个函数回避掉了直接使用字符串去传入 &lt;code&gt;Storyboard ID&lt;/code&gt; 的风险，但可以这么做的前提是，这里的 &lt;code&gt;EditVC&lt;/code&gt; 到 &lt;code&gt;“EditVC”&lt;/code&gt; 可以直接字符串化。&lt;/p&gt;
&lt;p&gt;如果你也要这么做的话，至少要保证你的类名的字符串化的结果和你的 &lt;code&gt;Storyboard ID&lt;/code&gt; 是有固定关联的。比如 &lt;code&gt;EditVC&lt;/code&gt; 对应 &lt;code&gt;“editvc”&lt;/code&gt; 或 &lt;code&gt;“EDITVC”&lt;/code&gt; 或 &lt;code&gt;“editVC”&lt;/code&gt; （这样你只要修改字母大小写就可以了），而不是 &lt;code&gt;“abc123”&lt;/code&gt; 这种随便写的东西。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;使用 storyboard 的时候，我们经常会写出下面这样的代码，用来跳转到其他页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; editVC = &lt;span
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>tableView updates 对比 reloadData</title>
    <link href="/2016/10/11/tableView-updates-%E5%AF%B9%E6%AF%94-reloadData/"/>
    <id>/2016/10/11/tableView-updates-对比-reloadData/</id>
    <published>2016-10-11T11:12:12.000Z</published>
    <updated>2016-10-11T11:13:10.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/updatesCompareReload.png&quot; alt=&quot;Paste_Image.png&quot;&gt;&lt;br&gt;如图有一个 TableView，每行显示这一行是第几行，现在我希望每按一次 update 按钮，就动态地在下方加两行。那么简单粗暴的做法是  ，更改数据源，然后刷新一下列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableView.reloadData()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用膝盖想也知道，这会使得前四行没有被改动的地方也被刷新一遍，带来了不必要的性能损耗。&lt;br&gt;好一点的做法是下面这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)
    tableView.beginUpdates()
    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; indexPaths = [&lt;span class=&quot;type&quot;&gt;IndexPath&lt;/span&gt;(row: tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, section: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;IndexPath&lt;/span&gt;(row: tableData.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, section: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)]
    tableView.insertRows(at: indexPaths, with: &lt;span class=&quot;type&quot;&gt;UITableViewRowAnimation&lt;/span&gt;.automatic)
    tableView.endUpdates()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与上面相比，这样做使得 &lt;code&gt;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell&lt;/code&gt; 方法被少调用了四次。&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;beginUpdates&lt;/code&gt; 和 &lt;code&gt;endUpdates&lt;/code&gt; 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。鉴于我这里只进行了一次 insert 操作，把这两条语句去掉也没事，但是出于规范还是应该写上，因为假如习惯不写，下面这样的代码会运行时崩溃：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@IBAction func &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;(_ sender: AnyObject) {
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;\(tableData.count)&quot;&lt;/span&gt;)
    tableData.append(&lt;span class=&quot;string&quot;&gt;&quot;\(tableData.count)&quot;&lt;/span&gt;)
    //        tableView.beginUpdates()
    tableView.insertRows(&lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt;: [IndexPath(&lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt;: tableData.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;section&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)], &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;: UITableViewRowAnimation.&lt;span class=&quot;keyword&quot;&gt;automatic&lt;/span&gt;)
    tableView.insertRows(&lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt;: [IndexPath(&lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt;: tableData.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;section&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)], &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;: UITableViewRowAnimation.&lt;span class=&quot;keyword&quot;&gt;automatic&lt;/span&gt;)
    //        tableView.endUpdates()
}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为第一次 insert 之后，当前 row 的总数量在 UI 上试图 4 变成 5，然而数据源是 6，它会检查使用者对 tableView 的 UI 操作，最后是不是和 numberOfRows 方法获取的值相对应。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;numberOfRows 方法调用：&lt;/strong&gt; 都只调用一次 numberOfRows 方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cellForRow 方法调用次数：&lt;/strong&gt; reloadData 会为当前显示的所有cell调用这个方法，updates 只会为新增的cell调用这个方法&lt;br&gt;&lt;strong&gt;cellForRow 方法调用时间：&lt;/strong&gt; reloadData 会在 numberOfRows 方法调用后的某一时间异步调用 cellForRow 方法，updates 会在 numberOfRows 方法调用后马上调用 cellForRow 方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reloadData 方法缺陷：&lt;/strong&gt; 带来额外的不必要开销，缺乏动画&lt;br&gt;&lt;strong&gt;updates 方法缺陷：&lt;/strong&gt;deleteRows 不会调用 cellForRow 方法，可能导致显示结果与数据源不一致；需要手动保证 insertRows、deleteRows 之后，row 的数量与 numberOfRows 的结果一致，否则会运行时崩溃&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;部分文章中没有写，总结提到了的部分放在完整 demo 里面了：&lt;a href=&quot;https://github.com/OpenMarshall/TableViewExplore&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo Github 地址&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/updatesCompareReload.png&quot; alt=&quot;Paste_Image.png&quot;&gt;&lt;br&gt;如图有一个 TableView，每行显示这一行是第几行，现在我希望每按一次
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用 UIPickerView 选择精确到街道的中国行政区划位置</title>
    <link href="/2016/08/26/%E7%94%A8-UIPickerView-%E9%80%89%E6%8B%A9%E7%B2%BE%E7%A1%AE%E5%88%B0%E8%A1%97%E9%81%93%E7%9A%84%E4%B8%AD%E5%9B%BD%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E4%BD%8D%E7%BD%AE/"/>
    <id>/2016/08/26/用-UIPickerView-选择精确到街道的中国行政区划位置/</id>
    <published>2016-08-26T06:17:22.000Z</published>
    <updated>2016-08-26T06:18:19.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/KYDivisionPickerViewScreenShot.png&quot; alt=&quot;ScreenShot&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，做了一个四列的 &lt;code&gt;UIPickerView&lt;/code&gt;，可以滑动选择精确到街道的中国行政区划信息，并返回地址，使用简单，直接像平时使用 &lt;code&gt;UIPickerView&lt;/code&gt; 一样，设置好  &lt;code&gt;frame&lt;/code&gt;，添加进父视图就好了。&lt;/p&gt;
&lt;p&gt;实现相应协议中的方法，可以在选择了地址之后，获取到相应地址信息的字符串，有兴趣欢迎戳进 &lt;a href=&quot;https://github.com/OpenMarshall/KYDivisionPickerView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目 Github 地址&lt;/a&gt;，随手 ✨✨✨✨✨&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/KYDivisionPickerViewScreenShot.png&quot; alt=&quot;ScreenShot&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，做了一个四列的 &lt;code&gt;UIPickerVie
    
    </summary>
    
    
      <category term="开源" scheme="/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>父视图外部子视图点击响应 - hitTest</title>
    <link href="/2016/08/19/%E7%88%B6%E8%A7%86%E5%9B%BE%E5%A4%96%E9%83%A8%E5%AD%90%E8%A7%86%E5%9B%BE%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94-hitTest/"/>
    <id>/2016/08/19/父视图外部子视图点击响应-hitTest/</id>
    <published>2016-08-19T03:36:55.000Z</published>
    <updated>2016-08-19T03:40:23.000Z</updated>
    
    <content type="html">&lt;p&gt;面试被问过两次了的一个问题，记录一下：&lt;strong&gt;假如一个 UIView（我们称作 FatherView），有一个 subview（我们称作 ChildView），这个 ChildView 在 FatherView 的 frame 外部，那么默认情况下，这个 ChildView 被点击的时候，并不会触发 FatherView 的点击响应链（这是合情合理的，FatherView 所在的位置都没被点击，它不遍历 subviews，不作回应是正常的），这时候怎样才能让这个 ChildView 相应点击事件？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实思路是很简单的，监控屏幕上的所有点击事件的区域，如果这个区域和我们的 UIView 以及其 subview 的 CGRect 有重合，就作出反应。&lt;/p&gt;
&lt;p&gt;也很容易查到 UIKit 提供了一个现成的方法来做到这件事：&lt;br&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Hit%20Testing%20a%20View.png&quot; alt=&quot;Hit Testing in a View&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Screen%20Shot.png&quot; alt=&quot;Screen Shot&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码是很简单的，现在让灰色的视图作为父视图，蓝色、红色的作为子视图，只要灰色视图实现了上述方法，就可以让蓝色视图像红色视图一样，可以相应点击事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Code%20Snippet.png&quot; alt=&quot;Code Snippet&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/Code%20Snippet2.png&quot; alt=&quot;Code Snippet&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OpenMarshall/HitTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;完整 Demo Github 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此都是很简单的内容，需要注意的如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你会发现 FatherView 里面的这个 &lt;code&gt;HitTest&lt;/code&gt; 会被频繁执行，你随便点击一个空白处，这个方法都会执行，这必然带来性能消耗，这也是 Apple 默认不使用这个方式的原因之一吧&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HitTest&lt;/code&gt; 会使得我们的蓝色的 UIView 可以相应点击，但是它被点击的之后，执行的方法我们应该按常规的方式写（比如给它加一个 &lt;code&gt;UIGestureRecognizer&lt;/code&gt; ，然后让这个 Gesture 有一个对应的 selector）。如果把需要执行的方法写在了 &lt;code&gt;HitTest&lt;/code&gt; 里面，写在 &lt;code&gt;return result&lt;/code&gt; 之前的话，我发现这些方法会多执行一次（在我当前写的这个简单 demo 里，我发现点击任意地方，&lt;code&gt;HitTest&lt;/code&gt; 方法都会连续执行两次）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://zhoon.github.io/ios/2015/04/12/ios-event.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;延伸阅读 - 深入浅出 iOS 事件机制&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;面试被问过两次了的一个问题，记录一下：&lt;strong&gt;假如一个 UIView（我们称作 FatherView），有一个 subview（我们称作 ChildView），这个 ChildView 在 FatherView 的 frame 外部，那么默认情况下，这个 Child
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>想一下再用 guard</title>
    <link href="/2016/07/18/%E6%83%B3%E4%B8%80%E4%B8%8B%E5%86%8D%E7%94%A8-guard/"/>
    <id>/2016/07/18/想一下再用-guard/</id>
    <published>2016-07-18T08:33:40.000Z</published>
    <updated>2016-07-18T08:34:09.000Z</updated>
    
    <content type="html">&lt;p&gt;自从知道了 &lt;code&gt;guard let&lt;/code&gt; 这种写法之后，我就几乎换掉了所有 &lt;code&gt;if let&lt;/code&gt; 写法。但今天要提醒一下，使用 &lt;code&gt;guard let&lt;/code&gt; 之前，需要先思考一下，因为这并不总是万全的解放方案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// bad&lt;/span&gt;
&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createMan0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: String?, country: String?, age: Int?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = name {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; country = country {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age = age {
                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;(name: name, country: country, age: age)
            }
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;comment&quot;&gt;// good&lt;/span&gt;
&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createMan1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: String?, country: String?, age: Int?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;? {
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = name &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; country = country &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age = age &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Man&lt;/span&gt;(name: name, country: country, age: age)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上的代码是很常见的 &lt;code&gt;guard let&lt;/code&gt; 使用场景，为了避免让我们写出 “Swift 鞭尸金字塔”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NetworkState&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Wifi&lt;/span&gt;
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(state:NetworkState)&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; state {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;:
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; speed = networkSpeed &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Cellular Speed: &lt;span class=&quot;subst&quot;&gt;\(speed)&lt;/span&gt;&quot;&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Wifi&lt;/span&gt;:
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; speed = networkSpeed &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Wifi Speed: &lt;span class=&quot;subst&quot;&gt;\(speed)&lt;/span&gt;&quot;&lt;/span&gt;)
    }
    &lt;span class=&quot;comment&quot;&gt;// 可能无法被执行&lt;/span&gt;
    doSomething()
}

test(.&lt;span class=&quot;type&quot;&gt;Cellular&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这种情况下，如果我们一看到 &lt;code&gt;networkSpeed&lt;/code&gt; 是可选型的，就决定使用 &lt;code&gt;guard … else {return}&lt;/code&gt; 语法，那么会出现的结果就是一旦 &lt;code&gt;networkSpeed&lt;/code&gt; 值为 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;doSomething()&lt;/code&gt; 将不会被执行。我们一开始可能仅仅是希望无法获取网速数值的时候，不在控制台打印相应信息，但现在整个 &lt;code&gt;test()&lt;/code&gt; 都被提前退出了。解决这个问题很简单，把 &lt;code&gt;guard … else {return}&lt;/code&gt; 改成  &lt;code&gt;guard … else {break}&lt;/code&gt;，让 &lt;code&gt;switch - case&lt;/code&gt; 里面的代码段提前退出就可以了。&lt;/p&gt;
&lt;p&gt;但是并不一定每种情况我们都要回避使用 &lt;code&gt;guard … else {return}&lt;/code&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;File&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Keynote&lt;/span&gt;
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;saveInBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( completion: File-&amp;gt;Void )&lt;/span&gt;&lt;/span&gt; {
    completion(.&lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;)
}

&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;closureTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
    saveInBackground( { file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; file {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Pages&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = fileName &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Pages: &lt;span class=&quot;subst&quot;&gt;\(name)&lt;/span&gt;&quot;&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;type&quot;&gt;Keynote&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = fileName &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;}
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Keynote: &lt;span class=&quot;subst&quot;&gt;\(name)&lt;/span&gt;&quot;&lt;/span&gt;)
        }
    })
    &lt;span class=&quot;comment&quot;&gt;// 一定会被执行&lt;/span&gt;
    doSomething()
}

closureTest()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种情况下，&lt;code&gt;return&lt;/code&gt; 所退出的方法是 &lt;code&gt;saveInBackground&lt;/code&gt; 函数里面的闭包 &lt;code&gt;completion: File-&amp;gt;Void&lt;/code&gt;，&lt;code&gt;saveInBackground&lt;/code&gt; 本身不受影响，如果 &lt;code&gt;saveInBackground&lt;/code&gt; 里面还有其他参数是闭包，那么其他闭包自然也不受影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;configureButton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(button:UIButton, buttonTitle:String?, buttonImage:UIImage?)&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; title = buttonTitle {
        button.setTitle(title, forState: .&lt;span class=&quot;type&quot;&gt;Normal&lt;/span&gt;)
    }
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; image = buttonImage {
        button.setImage(image, forState: .&lt;span class=&quot;type&quot;&gt;Normal&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在这种情况，&lt;code&gt;if let&lt;/code&gt; 语法就很自然，有 title 我们就设置 title，有 image 我们就设置 image，没有就算了，总不能说没有 title 或 image 就直接放弃当前的方法，或许我们后面还要做很多其他事情。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;没东西了&quot;&gt;没东西了&lt;/h1&gt;&lt;p&gt;希望大家在使用 &lt;code&gt;guard&lt;/code&gt; 关键字的时候多思考一下，以免犯下低级错误。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自从知道了 &lt;code&gt;guard let&lt;/code&gt; 这种写法之后，我就几乎换掉了所有 &lt;code&gt;if let&lt;/code&gt; 写法。但今天要提醒一下，使用 &lt;code&gt;guard let&lt;/code&gt; 之前，需要先思考一下，因为这并不总是万全的解放方案。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>集成 Weex 注意事项</title>
    <link href="/2016/06/19/%E9%9B%86%E6%88%90-Weex-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>/2016/06/19/集成-Weex-注意事项/</id>
    <published>2016-06-19T15:52:32.000Z</published>
    <updated>2016-06-19T15:53:04.000Z</updated>
    
    <content type="html">&lt;p&gt;撰写本文时，Weex 还没有完全开源，&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a21l5.77726.340855.2&amp;amp;docType=1&amp;amp;articleId=104742&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是官方的文档中心&lt;/a&gt;，&lt;a href=&quot;https://github.com/weexteam/article/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是 Weex 团队放在 Github 上的一些文章&lt;/a&gt;，你可以上&lt;a href=&quot;http://alibaba.github.io/weex/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;申请访问 Weex 的 Github 页面。&lt;/p&gt;
&lt;p&gt;这篇文章介绍一下如何快速集成 Weex 到你的 iOS Project 里面。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果你还没有 Weex 的 SDK，你可以下载一下这个官方给的 &lt;a href=&quot;http://gw.alicdn.com/bao/uploaded/LB1yfvtKpXXXXXbXXXXXXXXXXXX.zip?spm=a219a.7629140.0.0.ZqqSyg&amp;amp;file=LB1yfvtKpXXXXXbXXXXXXXXXXXX.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WeexSample&lt;/a&gt;，工程里面有 WeexSDK.framework 这个文件，这样如果你惯用 Objective-C 的话，参考&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a219a.7629140.0.0.sf2ubW&amp;amp;&amp;amp;docType=1&amp;amp;articleId=104829&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;，你就可以清晰明了地知道这个 Sample 是怎么写出来的，但是这篇文章没有告诉你这些事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里面有两个文件 SRWebSocket.h 和 SRWebSocket.m，这是 facebook 的开源项目 &lt;a href=&quot;https://github.com/facebook/SocketRocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SockerRocket&lt;/a&gt; ，运行这个项目必须有这个东西（至少暂时是这样，或许以后 Weex 团队会尝试自己搞个类似的东西出来？）&lt;/li&gt;
&lt;li&gt;官方目前没有 Swift 版本的 Sample，这里有个来自第三方的&lt;a href=&quot;https://github.com/acton393/WeexSwiftSample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;示例&lt;/a&gt;，可以参考一下，这个示例有一点点问题，代码风格不太 Swifty，问题我写在下面了，其他诸如 print 写成 NSLog 这种，无伤大雅，好歹是用 Swift 运行起来了&lt;/li&gt;
&lt;li&gt;Weex 是用 OC 写的，Swift 项目集成它，里面需要桥接文件，如果你不知道这个是什么，可以参考我&lt;a href=&quot;http://www.jianshu.com/p/27b9ff63ab6f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;之前的一篇文章&lt;/a&gt;，这个文件里面只需要写这些（不需要 import SRWebSocket）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXSDKEngine.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXSDKInstance.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXLog.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;WeexSDK/WXAppConfiguration.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;官方展示的 OC 版本的这段代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;
{
    &lt;span class=&quot;attr_selector&quot;&gt;[_instance destroyInstance]&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Swift 里面的写法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;// Deprecated&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//    override func finalize() {&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//        instance.destroyInstance()&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//    }&lt;/span&gt;

deinit {
    &lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt;.destroyInstance()
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虽然官方在很多地方都提到这一点，为了防止还是有人忽略，再写一遍：请在 Build Settings 的 Other Link Flags 里面加入 &lt;strong&gt;-ObjC&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网开源的代码中，没有把 SDK 做成 .framework，而是直接一个文件夹，工程通过 Pod 来把这个 SDK 集成到项目中，顺便也通过 Pod 集成了其他内容，这是 Podfile 里的内容（可以看到 WeexSDK 是通过本地路径加进来的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source &lt;span class=&quot;string&quot;&gt;&#39;https://github.com/CocoaPods/Specs.git&#39;&lt;/span&gt;
platform &lt;span class=&quot;symbol&quot;&gt;:ios&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;7.0&#39;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;#inhibit_all_warnings!&lt;/span&gt;

target &lt;span class=&quot;string&quot;&gt;&#39;WeexDemo&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;WeexSDK&#39;&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:path=&amp;gt;&lt;span class=&quot;string&quot;&gt;&#39;../sdk/&#39;&lt;/span&gt;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;SDWebImage&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;3.7.5&#39;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;SocketRocket&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;0.4.2&#39;&lt;/span&gt;
  pod &lt;span class=&quot;string&quot;&gt;&#39;ATSDK-Weex&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;0.0.1&#39;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;撰写本文时，Weex 还没有完全开源，&lt;a href=&quot;https://open.taobao.com/doc2/detail?spm=a21l5.77726.340855.2&amp;amp;docType=1&amp;amp;articleId=104742&quot; target=&quot;_bla
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Controller 之间使用代理传值</title>
    <link href="/2016/05/18/Controller-%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E4%BC%A0%E5%80%BC/"/>
    <id>/2016/05/18/Controller-之间使用代理传值/</id>
    <published>2016-05-17T16:53:52.000Z</published>
    <updated>2016-05-17T16:54:31.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/delegatePassData.gif&quot; alt=&quot;Controller 传值&quot;&gt;&lt;br&gt;控制器之间经常需要互相传递值，第一个控制器（简称 MasterVC）在通过 NavigationController Push 第二个控制器（简称 DetailVC）的时候，可以捕获到 DetailVC，所以可以设定后者的变量。而 DetailVC 在给 MasterVC 传递值的时候，比如设定 MasterVC 的 Title，却不能用同样的方式传值（试一下就知道了），而且因为我们要通过 NavigationController 返回原来的界面而不是 push 一个新的界面，所以也不能通过 segue 传值，解决方法我尝试了两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 static var&lt;/li&gt;
&lt;li&gt;使用代理传值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用_static_var&quot;&gt;使用 static var&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MasterVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; text:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;! = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewWillAppear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(animated: Bool)&lt;/span&gt;&lt;/span&gt; {
        title = &lt;span class=&quot;type&quot;&gt;MasterVC&lt;/span&gt;.text
    }
}

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DetailVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewWillDisappear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(animated: Bool)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;type&quot;&gt;MasterVC&lt;/span&gt;.text = &lt;span class=&quot;string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样虽然行得通，但是代码丑陋：类似 viewWillAppear 这样的方法，让人难以读懂，为什么这样的事情要在这个地方做，没有明显的道理；在 MasterVC 内部，仍然需要以 &lt;code&gt;MasterVC.text&lt;/code&gt; 这样蹩脚的方式调用。&lt;/p&gt;
&lt;h2 id=&quot;使用代理传值&quot;&gt;使用代理传值&lt;/h2&gt;&lt;p&gt;说白了我们只是希望 MasterVC 有一个 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 这样的方法，然后在 DetailVC 里面适时地调用这个方法就好了。于是解决方案是：将 MasterVC 设为 DetailVC 的代理，DetailVC 以代理作为桥梁，来调用 MasterVC 里面的 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 方法，而 MasterVC 只需要遵守一个相应的传值协议，协议里面要求必须实现的方法，就是 &lt;code&gt;setControllerTitle(text:String)&lt;/code&gt; 这个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;comment&quot;&gt;//  PassDataDelegate.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Foundation

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PassDataDelegate&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setControllerTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text:String)&lt;/span&gt;&lt;/span&gt;
}


&lt;span class=&quot;comment&quot;&gt;//  MasterVC.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MasterVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;PassDataDelegate&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;preprocessor&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textField: &lt;span class=&quot;type&quot;&gt;UITextField&lt;/span&gt;!

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - Pass Data&lt;/span&gt;
    &lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;goNextController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vc = storyboard?.instantiateViewControllerWithIdentifier(&lt;span class=&quot;string&quot;&gt;&quot;DetailVC&quot;&lt;/span&gt;)
            &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;DetailVC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; txt = textField.text &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
        vc.title = txt &lt;span class=&quot;comment&quot;&gt;// pass data&lt;/span&gt;
        vc.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// get data by set delegate&lt;/span&gt;
        navigationController?.pushViewController(vc, animated: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - PassDataDelegate Method&lt;/span&gt;
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setControllerTitle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text:String)&lt;/span&gt;&lt;/span&gt; {
        title = text
    }

}


&lt;span class=&quot;comment&quot;&gt;//  DetailVC.swift&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DetailVC&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;preprocessor&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; textField: &lt;span class=&quot;type&quot;&gt;UITextField&lt;/span&gt;!
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delegate: &lt;span class=&quot;type&quot;&gt;PassDataDelegate&lt;/span&gt;!

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()
    }


    &lt;span class=&quot;comment&quot;&gt;// MARK: - Pass Data&lt;/span&gt;
    &lt;span class=&quot;preprocessor&quot;&gt;@IBAction&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;goBackLastController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(sender: AnyObject)&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; delegate != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; txt = textField.text &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; }
            delegate.setControllerTitle(txt)
        }
        navigationController?.popViewControllerAnimated(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相比之前的方法，我们获得的额外的好处是：假如我们传递的不只是字符串，而是大量的信息，比如十个不同类型的值，使用代理传值依然只需要实现一个方法，而在之前的解决方案中，我们需要写十行 &lt;code&gt;static var&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OpenMarshall/PassDataByDelegate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;完整项目&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xssu3.com1.z0.glb.clouddn.com/delegatePassData.gif&quot; alt=&quot;Controller 传值&quot;&gt;&lt;br&gt;控制器之间经常需要互相传递值，第一个控制器（简称 MasterVC）在通过 Navig
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 结合 UISearchBar 问题解决</title>
    <link href="/2016/05/06/UITableView-%E7%BB%93%E5%90%88-UISearchBar-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>/2016/05/06/UITableView-结合-UISearchBar-问题解决/</id>
    <published>2016-05-06T09:36:26.000Z</published>
    <updated>2016-05-06T09:36:55.000Z</updated>
    
    <content type="html">&lt;p&gt;之前看了 &lt;a href=&quot;https://www.raywenderlich.com/113772/uisearchcontroller-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ray Wenderlich 的一篇文章&lt;/a&gt; 学习了一下怎么把 UISearchBar 放在 UITableView 的头部，来进行列表搜索，然后发现了两个问题，用了好久才解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UISearchBar 有个 1 像素宽的黑色边框，去不掉&lt;/li&gt;
&lt;li&gt;把 UISearchBar 放在 UITableView 头部的代码在 iOS 8 不起作用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;tableView&lt;span class=&quot;class&quot;&gt;.tableHeaderView&lt;/span&gt; = searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// now working&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;解决问题_1&quot;&gt;解决问题 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.layer&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.borderWidth&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;
searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.layer&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.borderColor&lt;/span&gt; = &lt;span class=&quot;comment&quot;&gt;// your background color&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;解决问题_2&quot;&gt;解决问题 2&lt;/h3&gt;&lt;p&gt;我发现 tableHeaderView 是可以被其他 view 有效填充的，不知道为什么 searchBar 就是放不进去，所以直接找个大小一样的 UIView 作为容器放在 searchBar 下面就好了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let containerView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, view.frame.width, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)
containerView&lt;span class=&quot;class&quot;&gt;.backgroundColor&lt;/span&gt; = &lt;span class=&quot;comment&quot;&gt;// your background color&lt;/span&gt;
searchController&lt;span class=&quot;class&quot;&gt;.searchBar&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.frame&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;CGRectMake&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, view.frame.width, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
containerView.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;addSubview&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(searchController.searchBar)&lt;/span&gt;&lt;/span&gt;
tableView&lt;span class=&quot;class&quot;&gt;.tableHeaderView&lt;/span&gt; = containerView
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;之前看了 &lt;a href=&quot;https://www.raywenderlich.com/113772/uisearchcontroller-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ray Wenderlich 的一篇文章&lt;/a&gt; 学
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>初识函数式 Swift 实用</title>
    <link href="/2016/04/29/%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0%E5%BC%8F-Swift-%E5%AE%9E%E7%94%A8/"/>
    <id>/2016/04/29/初识函数式-Swift-实用/</id>
    <published>2016-04-29T09:20:15.000Z</published>
    <updated>2016-04-29T09:20:40.000Z</updated>
    
    <content type="html">&lt;p&gt;Swift 的语言特性使得它非常适合被用于以函数式编程思想，如果你还没开始用函数式的方式来使用它，那么可以从现在开始，尝试着利用函数式的便利性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: view.frame)&lt;/span&gt;&lt;/span&gt;
indicateView&lt;span class=&quot;class&quot;&gt;.image&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(named: &lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(indicateView)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我刚刚写了上面这段代码，来让我的当前页面显示名为 “how2use” 的这张图片。看起来好像是我做了三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 frame 创建 UIImageView&lt;/li&gt;
&lt;li&gt;根据图片名称配置 UIImageView&lt;/li&gt;
&lt;li&gt;将 UIImageView 作为 subview 传给其他 view&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是实际上，我只需要 frame、imageName 这两个东西就可以把这三行代码配置好，或者说我能不能用这两个参数来把上面的三行代码缩减为一行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(rect:CGRect)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame = rect
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(imageName:String)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.image = &lt;span class=&quot;type&quot;&gt;UIImage&lt;/span&gt;(named: imageName)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;placeSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(view:UIView)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        view.addSubview(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写了上面这些方法之后，代码修改成这个样子了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(view.frame)&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
        .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;placeSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self.view)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了代码可读性，这里我写了四行，但显然这是一行代码。&lt;br&gt;继而我发现 indicateView 这个名字没有存在的必要，于是我废弃掉 placeSelf 这个方法，改成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
    .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;frameSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(view.frame)&lt;/span&gt;&lt;/span&gt;
    .&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;imageSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;how2use&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一行代码，不引入多余的变量。&lt;br&gt;如果你愿意的话，这个模式还可以继续写下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIImageView&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tagSelf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(tag:Int)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.tag = tag
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }

    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modeSelf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(contentMode:UIViewContentMode)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIImageView&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.contentMode = contentMode
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后代码会变成这种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;......
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;上面这些代码的优势在于：类似 indicateView 这种东西，用一次就不要了，没必要引入新的名称，不便于理解和记忆，我们就可以函数式地把它解决掉，代码更精简易读。&lt;/li&gt;
&lt;li&gt;上面我用了 xxxxSelf 这种方式来表明，这种方法不是用一下就完了，它会返回这个对象本身，所以你还可以继续做别的事情。但是这种命名方式我个人看来不够好，唯一好的地方可能只是在于：本来我想设置 imageView.tag = 100，结果敲出 tag 这三个字母，Xcode 就提示我有 tagSelf 这个方法可以用，这可以让我方便地自动补全这个方法，不需要记忆方法名。&lt;/li&gt;
&lt;li&gt;这种编程方式的优点之一在于不同方法之间的组合性，如果你想把上面这些方法整合到一个函数里，然后通过传一大堆的参数来进行调用，是画蛇添足。&lt;/li&gt;
&lt;li&gt;显然这种方式有其弊端，不宜滥用，而且修改代码的时候要注意：假如你要改动 func2，注意它和 func1、func3 之间是不是存在什么先后关系。特别是你用这种方式来给图片做滤镜处理的时候，一张图片先高斯模糊再打马赛克，先打马赛克再高斯模糊是完全不同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;userImage.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;mosaic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 马赛克本身是清晰的&lt;/span&gt;
userImage.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;mosaic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 马赛克本身是模糊的&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 的语言特性使得它非常适合被用于以函数式编程思想，如果你还没开始用函数式的方式来使用它，那么可以从现在开始，尝试着利用函数式的便利性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let indicateView = &lt;span class=&quot;function&quot;&gt;&lt;span c
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 setNeedsLayout 说起</title>
    <link href="/2016/04/27/%E4%BB%8E-setNeedsLayout-%E8%AF%B4%E8%B5%B7/"/>
    <id>/2016/04/27/从-setNeedsLayout-说起/</id>
    <published>2016-04-27T08:01:39.000Z</published>
    <updated>2016-04-27T08:03:43.000Z</updated>
    
    <content type="html">&lt;p&gt;本文从 &lt;code&gt;setNeedsLayout&lt;/code&gt; 这个方法说起，分享与其相关的 UIKit 视图交互、使用场景等内容。&lt;/p&gt;
&lt;p&gt;UIKit 为 UIView 提供了这些方法来进行视图的更新与重绘：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsLayout&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;layoutSubviews&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;layoutIfNeeded&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsDisplay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNeedsDisplayInRect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rect: CGRect)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drawRect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(rect: CGRect)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;运行时视图交互模型&quot;&gt;运行时视图交互模型&lt;/h2&gt;&lt;p&gt;无论是用户交互触发还是代码自动触发，下图展示的事件序列都同样适用，这里用到了 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/UIKit%20interactions%20with%20your%20view%20objects.png&quot; alt=&quot;UIKit interactions with your view objects&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图对应的事件序列如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户触摸屏幕&lt;/li&gt;
&lt;li&gt;硬件报告触摸事件给 UIKit 框架 &lt;/li&gt;
&lt;li&gt;UIKit 框架将触摸事件打包成 UIEvent 对象，然后分发给合适的视图&lt;/li&gt;
&lt;li&gt;事件处理代码会对相应事件作出响应，代码可以是这样的：&lt;br&gt;-更改  &lt;code&gt;frame&lt;/code&gt;、&lt;code&gt;bounds&lt;/code&gt;、&lt;code&gt;alpha&lt;/code&gt; 等属性&lt;br&gt;-调用 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法以标记该视图（或者它的子视图）为需要进行布局更新&lt;br&gt;-调用 &lt;code&gt;setNeedsDisplay&lt;/code&gt; 或者 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 方法以标记该视图（或者它的子视图）需要进行重画&lt;br&gt;-通知 Controller 有数据变化&lt;/li&gt;
&lt;li&gt;如果一个视图的几何结构改变了，UIKit 会更新它的子视图&lt;/li&gt;
&lt;li&gt;如果任何视图的任何部分被标记为需要重画，UIKit 会要求视图重画自身&lt;/li&gt;
&lt;li&gt;任何已经更新的视图会与应用余下的可视内容组合在一起，同时被发送到图形硬件去显示&lt;/li&gt;
&lt;li&gt;图形硬件将已解释内容转化到屏幕上&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;方法调用逻辑&quot;&gt;方法调用逻辑&lt;/h2&gt;&lt;p&gt;在上面的过程中，我们可以接触到文章开头提到的方法，他们的调用逻辑是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;setNeedsLayout&lt;/code&gt; 会给当前 UIView 立一个 flag，以表示后续应该调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 方法，以调整当前视图及其子视图的布局。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 会给当前 UIView 立一个 flag，以表示后续应该调用 &lt;code&gt;drawRect:&lt;/code&gt; 方法，以进行视图重绘。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;View_Drawing_Cycle&quot;&gt;View Drawing Cycle&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple 官方文档&lt;/a&gt;已经明确说明，开发者不应该直接调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 与  &lt;code&gt;drawRect:&lt;/code&gt; ，而应该&lt;strong&gt;在你认为系统默认的布局和重绘不能带给你想要的效果时，在子类中重写这些方法，然后分别通过 &lt;code&gt;setNeedsLayout&lt;/code&gt; 和 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 来进行调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然你可以给多个 UIView 设置 &lt;code&gt;setNeedsLayout&lt;/code&gt;，然后当下一个 View Drawing Cycle 到来时，多个 UIView 的视图会一同更改布局。&lt;/p&gt;
&lt;p&gt;那么这个 View Drawing Cycle 到底是什么呢，官方是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The system waits until the end of the current run loop before initiating any drawing operations. This delay gives you a chance to invalidate multiple views, add or remove views from your hierarchy, hide views, resize views, and reposition views all at once. All of the changes you make are then reflected at the same time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然这样用 RunLoop 把多次修改聚集在一个 Cycle 一并进行渲染是更加高效的行为。&lt;/p&gt;
&lt;p&gt;（我个人对 View Drawing Cycle 的理解是这样的：UIKit 需要处理非常多的事件，这些事件组合起来变成了一个非常复杂的事件序列，在这个序列中有些特定的点是 UIKit 专门提供给 UIView 来进行视图更改的。如上所述，在当前 run loop 结束之前，我们有机会做各种视图更改，并且这些更改会在下一个 run loop 体现出来，所以&lt;strong&gt; View Drawing Cycle 就是一次次 run loop 中我们通过 UIKit 得到的 UIView 重布局、重绘机会所组成的循环&lt;/strong&gt;。有理解不对的地方，欢迎评论指正。）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;如何善用_View_Drawing_Cycle&quot;&gt;如何善用 View Drawing Cycle&lt;/h2&gt;&lt;p&gt;一个很常见的例子是，一个 iPad App，横屏和竖屏时界面布局不一样，那么你可以监听设备旋转，在设备旋转时执行 &lt;code&gt;setNeedsLayout&lt;/code&gt; 方法，然后在 &lt;code&gt;layoutSubviews&lt;/code&gt; 里面通过判断接下来是横屏还是竖屏来进行不一样的布局设置。基本上你不可能只在这个方法里只进行了单个 UIView 的布局修改，而是多项修改，那么 App 会在下一个 View Drawing Cycle 到来时，把这些修改一起执行，这是最正常的情况。&lt;/p&gt;
&lt;p&gt;那么假如我不按 Apple 规定的来，直接调用 &lt;code&gt;layoutSubviews&lt;/code&gt;  呢？我们可以猜想一下：因为这个方法里面提供了我们需要的布局方式，所以 UIView 会按我们想要的方式来布局，但是因为各种视图修改的请求时机是零碎的，所以这样效率会低一些。所以重要的其实是了解何时会触发 &lt;code&gt;layoutSubviews&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init 初始化不会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;addSubview 会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;设置 view 的 frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化&lt;/li&gt;
&lt;li&gt;滚动一个 UIScrollView 会触发 layoutSubviews&lt;/li&gt;
&lt;li&gt;旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件&lt;/li&gt;
&lt;li&gt;改变一个 UIView 大小的时候也会触发父 UIView 上的 layoutSubviews 事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后按 Apple 要求的方式来做就好了（分别通过 &lt;code&gt;setNeedsLayout&lt;/code&gt; 和 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt; 来调用 &lt;code&gt;layoutSubviews&lt;/code&gt; 和  &lt;code&gt;drawRect:&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;但有些情况比较特殊：你打开 iOS 的时钟应用，去看里面的秒表页面，这个页面里面的两个按钮是没有 UIButton 默认的动画的，点击之后，按钮会瞬间改变自身的状态（颜色、内部 Label 的内容），这种情况我们需要跳出 View Drawing Cycle，来实现一个瞬间改变的效果。实现方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIButton&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickButtonAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;.performWithoutAnimation({
            &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.layoutIfNeeded()
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出 &lt;code&gt;layoutIfNeeded&lt;/code&gt; 作为一个辅助选项给了 &lt;code&gt;setNeedsLayout&lt;/code&gt; 一个可以瞬时执行的特点。当然默认这个“选项”是关闭的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;setNeedsDisplay_补充&quot;&gt;setNeedsDisplay 补充&lt;/h2&gt;&lt;p&gt;&lt;code&gt;setNeedsLayout&lt;/code&gt; 的使用场景之前已经提过了（iPad App），下面举个栗子说一下 &lt;code&gt;setNeedsDisplayInRect: &lt;/code&gt;的使用场景。&lt;/p&gt;
&lt;p&gt;假如我需要在两点之间绘制一条直线，有两个 &lt;code&gt;dotView&lt;/code&gt;，需要绘制一个 &lt;code&gt;lineView&lt;/code&gt;。我在 &lt;code&gt;drawRect:&lt;/code&gt; 方法里实现了 &lt;code&gt;lineView&lt;/code&gt; 的具体绘制方法（根据两个点来绘制）。那么如果我想要这个直线一直根据两个点同步变化的话，就需要在 &lt;code&gt;dotView&lt;/code&gt; 的位置发生改变时，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lineView.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;setNeedsDisplay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 重绘 lineView&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于 &lt;code&gt;drawRect:&lt;/code&gt; 方法什么时候会被触发：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/From%20StackOverFlow.png&quot; alt=&quot;From StackOverFlow&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个很好的参考链接：&lt;a href=&quot;http://stackoverflow.com/questions/2807137/what-is-the-relationship-between-uiviews-setneedslayout-layoutifneeded-and-lay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is the relationship between UIView’s setNeedsLayout, layoutIfNeeded and layoutSubviews?&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文从 &lt;code&gt;setNeedsLayout&lt;/code&gt; 这个方法说起，分享与其相关的 UIKit 视图交互、使用场景等内容。&lt;/p&gt;
&lt;p&gt;UIKit 为 UIView 提供了这些方法来进行视图的更新与重绘：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在这个行当，不做程序员也得懂技术</title>
    <link href="/2016/04/17/%E5%9C%A8%E8%BF%99%E4%B8%AA%E8%A1%8C%E5%BD%93%EF%BC%8C%E4%B8%8D%E5%81%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF/"/>
    <id>/2016/04/17/在这个行当，不做程序员也得懂技术/</id>
    <published>2016-04-17T04:51:45.000Z</published>
    <updated>2016-04-17T04:52:29.000Z</updated>
    
    <content type="html">&lt;p&gt;先来捋一捋思路，关于各个岗位合作打造（移动端）产品的一点想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么只有程序员是不够的&lt;/li&gt;
&lt;li&gt;如何做一个好的非程序员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;声明：&lt;br&gt;本人是程序员，截止到目前，我用的设计都是自己设计的，我用的产品策略都是自己的思考。&lt;br&gt;本人并非专业设计师或 PM，如果勘误，欢迎指正。&lt;br&gt;本文并非对设计师和 PM 的吐槽，但如果您觉得您作为设计师或 PM 或其他职业者被冒犯了，我只能说我并无此意，请您立刻关闭此页面。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么只有程序员是不够的&quot;&gt;为什么只有程序员是不够的&lt;/h2&gt;&lt;p&gt;&lt;br&gt;首先要消除一下歧义，我们见过无数的一人独挑大梁完爆数十人团队的例子，所以事实证明，只有一个程序员，某些时候是足够的。不够背后隐含的是，这个程序员做了很多非程序员岗位的事情，这种情况下其实相当于是一个 Product Creater 在做东西，他（她）不仅仅是程序员这么简单。&lt;/p&gt;
&lt;p&gt;即便是在移动端出现之前，大家在 PC 上用软件，也是需要有人来做设计，有人来思考产品的。&lt;/p&gt;
&lt;p&gt;用户完成一个操作，需要做几次操作，需要做什么样的操作，PC 上是鼠标左击、右击、滑动还是其他，移动端是滑动、点按、长按亦或重按。这个产品解决了什么样的问题，用什么方式解决的，其他产品解决了这个问题吗，它们是怎么解决的，你和它们相比有什么不同……这款产品有自己的设计风格吗，如果是依照平台的风格，那么有什么地方没遵循平台的规范吗，能不能先破再立，开创一个新的形态……&lt;/p&gt;
&lt;p&gt;类似的问题太多太多，于是有了【程序员+设计师+PM】的模型。&lt;/p&gt;
&lt;p&gt;最近想明白了一件事情：为什么身边好多人我明确地知道他们代码写的比我好，但是做不出好东西？&lt;/p&gt;
&lt;p&gt;去年 8 月份我做了自己的第一款在 App Store 上架的 App，花了 12 天，2000 行 Swift。这个项目如果是现在做的话，从 0 到打包 ipa，两天以内，最多 800 行代码就可以搞定。然而就是这份臃肿不看、风格丑陋的代码，带领这个 App 杀进了 App Store 中国区付费榜 Top 50。&lt;/p&gt;
&lt;p&gt;还有就是现在的编码能力相比从前有了十足的进步，面向协议编程、函数式编程也都有了了解，对可以重构的项目大刀阔斧地更改，改代码的时候心潮那叫一个澎湃啊，觉得自己写出了多么多么厉害的代码。等写完了，冷静一看，原来不过如此。代码是变了，App 表现起来和原来并没有什么区别，这种努力用户是看不见的。&lt;/p&gt;
&lt;p&gt;所以逐渐开始认识到，代码和产品是多么割裂开的事情。当然好的程序员可以把这些事情想办法联系起来，融会贯通，知道什么样的 App 导航模式可能对应背后什么样的设计模式（举了个不好的例子）。但说到底这是完全不同的两件事。&lt;/p&gt;
&lt;h2 id=&quot;如何做一个好的非程序员&quot;&gt;如何做一个好的非程序员&lt;/h2&gt;&lt;p&gt;&lt;br&gt;做外包的经常觉得甲方很蠢、各种难沟通，所谓隔行如隔山，甲方或许会说出 “这个设计看着不大气啊” 或者 “我想做一个淘宝那样的网站，得多少钱” 这样的话，然后乙方就在内心嘲笑人家，但是身体上还要表现的无所谓，最终把钱搞到手。&lt;/p&gt;
&lt;p&gt;但其实真的没必要这样，因为对方是来提出需求的，假如让我进入一个完全没有概念的领域，比如说挑选木材，我也只能说我想要像什么什么一样的木材，我叫不上名字的。所以甲方这样无可厚非。但同时我们也知道，一个好的甲方，我们可能希望他懂技术、懂设计、懂产品，和我们交流起来纵享丝滑。&lt;/p&gt;
&lt;p&gt;程序员、设计师、PM 三方对接的时候，其实就是这么个甲乙方的关系，而理想状况下，这三方中的任何一方充当甲方的时候，都应该是一个可以进行无障碍对接的甲方。&lt;/p&gt;
&lt;p&gt;比如说颜色，设计师眼里的颜色是这样的：&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF0.png&quot; alt=&quot;KUWAZOME&quot;&gt;&lt;br&gt;同样的东西在程序员眼里是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let kuwazomeColor = UIColor(red: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, green: &lt;span class=&quot;number&quot;&gt;54&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, blue: &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, alpha: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么好的设计师应该是以这样的方式把这个颜色传递给程序员的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;# 颜色&lt;/span&gt;
KUWAZOME: R &lt;span class=&quot;number&quot;&gt;0.39&lt;/span&gt; - G &lt;span class=&quot;number&quot;&gt;0.21&lt;/span&gt; - B &lt;span class=&quot;number&quot;&gt;0.23&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KUWAZOME: &lt;span class=&quot;hexcolor&quot;&gt;#6B4449&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;作为设计师，你可以不会写代码，你可以不知道什么是 UIColor 什么是 CGColor 什么是 NSColor，但是你要知道用你的东西的人此时此刻是以 RGB 或 HSB 的方式用的，而不是 CSS HEX，这是非常基本的要求。再甚者你还应该知道你的程序员使用的 IDE 可能不会帮他补全 &lt;code&gt;/255&lt;/code&gt; 这一内容，所以为了让他不再打出无数个 &lt;code&gt;/255&lt;/code&gt; ，你给他的值应该是 &lt;code&gt;R: 0.39&lt;/code&gt;  而不是 &lt;code&gt;R: 100&lt;/code&gt;  。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么作为程序员，你应该能看得懂 &lt;code&gt;#6B4449&lt;/code&gt; 是什么意思，并具有把它转换成 RGB 或 HSB 数值的能力，这样可以保证你在遇到了相对糟糕的设计师的时候，也能完成任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好的设计师应该把程序员培养成设计领域的废人，程序员指定图片名，设计师这边把相应图片导出，名称、尺寸分毫不差，并附带 1x、2x、3x 给 iOS，各种 dpi 给 Android。而程序员这边即便只拿到了 .psd 或 .sketch 文件也能把项目做完。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，无论是程序员、设计师还是 PM，都应该了解大家共同面对的这个平台，依然拿 iOS 举例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%9F%E5%BE%97%E6%87%82%E6%8A%80%E6%9C%AF1.png&quot; alt=&quot;UIAlertController&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面这个是 iOS 系统提供的控件 - UIAlertController，这个东西在程序员眼里表现起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let alert = &lt;span class=&quot;built_in&quot;&gt;UIAlertController&lt;/span&gt;(
    title: &lt;span class=&quot;string&quot;&gt;&quot;A Short Title Is Best&quot;&lt;/span&gt;,
    message: &lt;span class=&quot;string&quot;&gt;&quot;A message should be a short, complete sentence.&quot;&lt;/span&gt;,
    preferredStyle: &lt;span class=&quot;built_in&quot;&gt;UIAlertControllerStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.ActionSheet&lt;/span&gt;)

alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Cancel&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Cancel&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Choice One&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Default&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
alert&lt;span class=&quot;variable&quot;&gt;.addAction&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;UIAlertAction&lt;/span&gt;(title: &lt;span class=&quot;string&quot;&gt;&quot;Choice Two&quot;&lt;/span&gt;,
    style: &lt;span class=&quot;built_in&quot;&gt;UIAlertActionStyle&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.Default&lt;/span&gt;,
    handler: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以程序员此时需要的信息是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;preprocessor&quot;&gt;# UIAlertController&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;title:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;A Short Title Is Best&quot;&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;message:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;A message should be a short, complete sentence.&quot;&lt;/span&gt;
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Cancel&quot;&lt;/span&gt; - Cancel
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Choice One&quot;&lt;/span&gt; - Default
&lt;span class=&quot;label&quot;&gt;Action:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Choice Two&quot;&lt;/span&gt; - Default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就足够了。当然你可以把上面那张图也做出来给程序员预览，防止出错，但是你要明白这个东西是 iOS 系统提供的，UIAlertController 是现成可调用的 API，你要做的是只是提供调用这个 API 需要的参数，而不是做一个一模一样的 UIAlertController，还把图片裁成 1x、2x、3x 以为这个东西是程序员手动做的。如果这个东西真的是程序员手动做的，那么显然你应该把 Cancel、Choice One、Choice Two 这三个东西分开提供图片资源，否则怎么可能会有三个可点击的地方？!&lt;/p&gt;
&lt;p&gt;又或者说某个可点击控件被点击之后的效果，iOS 有自己的 Human Interface Guidelines，Android 有 Google 提供的 Material Design，你只要给 Button 提供里面的 Image 资源就可以了，告诉客户端开发的程序员阴影模糊几像素、向右偏移几像素、向下偏移几像素是极其不专业的行为。&lt;strong&gt;同样的，作为设计师，你可以不懂 UIButton 怎么创建，但是你要搞清楚 “iOS 里面的 Button” 或者 “Android 里面的 Button” 到底是什么，了解你的设计应该以怎么样的形式被融入到程序员的工作中，这才是设计，否则只是美工，更何况连图片资源都不能正常提供，连美工都算不上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似的例子太多太多了……&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;或许这篇文章的标题还可以改成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在这个行当，不做设计师也得懂设计&lt;/li&gt;
&lt;li&gt;在这个行当，不做产品经理也得懂产品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不想吐槽，只想分享一点自己的看法，我觉得真正的专业，不仅是把自己份内的事做好这么简单，因为常常和你合作的人并不能把他份内的事做好。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先来捋一捋思路，关于各个岗位合作打造（移动端）产品的一点想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么只有程序员是不够的&lt;/li&gt;
&lt;li&gt;如何做一个好的非程序员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;声明：&lt;br&gt;本人是程序员，截止到目前，我用的设计都是自己设计的，我用的
    
    </summary>
    
    
      <category term="其他" scheme="/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ViewController 减负记录</title>
    <link href="/2016/04/16/ViewController-%E5%87%8F%E8%B4%9F%E8%AE%B0%E5%BD%95/"/>
    <id>/2016/04/16/ViewController-减负记录/</id>
    <published>2016-04-16T12:58:18.000Z</published>
    <updated>2016-04-16T13:04:30.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;最近在重构一个以前写的老项目，在尝试给之前的 ViewController 减负，尽量抽离代码到其他文件。&lt;br&gt;想记录一些东西，看看以后返回来再看能不能有更好的想法；而现在，可以作为一个检验当前代码是否需要优化的一个标准。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;整合常量&quot;&gt;整合常量&lt;/h3&gt;&lt;p&gt;以前喜欢在 ViewController 的顶部（class 外面）写一些全局变量，这样虽然可以写一次创建的代码，就可以在整个项目的任意地方使用。但是，基本上你不可能只有一个 ViewController，有了这种习惯之后，会让全局变量没有逻辑地分散在不同的代码文件里，不易于管理（甚至可能会出现同一个东西以不同的名字被创建了多次的情况），而且代码可读性会严重降低（因为你看见这个变量的时候，你可能并不知道它是全局的）。&lt;/p&gt;
&lt;p&gt;解决起来其实很简单，我当前这个项目的缩写是 GM，于是我建了一个叫 GMConstants 的 Class，把所有之前的全局变量都放到这里，写成 &lt;code&gt;static let&lt;/code&gt; 的形式。（除非你真的知道这样没问题，否则不建议写 &lt;code&gt;static var&lt;/code&gt;，或创建 GMVariables Class，这样会导致你使用这些量的时候，依然不知道具体这些是什么，因为它们可能被更改过）&lt;/p&gt;
&lt;p&gt;比如之前我设定了我这个 App 中使用的所有的灰色都应该是一样的，我写了一个 gmGreyColor 的常量，使用的时候，你可能并不记得这么一个东西是全局的，并且担心除了灰色，还有什么颜色，是不是还有个 gmBlackColor？甚至你可能写了一个意义相同的 gmGrayColor，仅仅是因为 grey 和 gray 同义。而现在，你的使用方式应该是 &lt;code&gt;GMConstants.greyColor&lt;/code&gt;——一看便知是什么意思，而且按住 cmd 键，鼠标左击 GMConstants 关键词，你还可以看见你到底创建了几个类似这样的颜色。&lt;/p&gt;
&lt;p&gt;当你想写全局变量，或者发现某个局部变量，在不同的地方被多次使用的时候，就该考虑这个问题了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;布尔标记&quot;&gt;布尔标记&lt;/h3&gt;&lt;p&gt;刚刚提到不建议以整合常量的方式来整合变量，不过后续又发现之前会用这样一种方式来处理逻辑：先写一个值为 &lt;code&gt;false&lt;/code&gt; 的布尔变量，以此作为一种标记，后续根据情况来不断地修改该值为  &lt;code&gt;true&lt;/code&gt; 或者 &lt;code&gt;false&lt;/code&gt; ，来判断某些语句是否应该执行。&lt;/p&gt;
&lt;p&gt;虽然目前认为这种方式并不是优雅的写法，因为这样一个布尔标记的作用范围太大了，虽然写代码的时候知道，某种情况 &lt;code&gt;true&lt;/code&gt;，另一种情况 &lt;code&gt;false&lt;/code&gt;，但以后修改的时候，就要求程序员有全局观才能尝试修改或移除这个标记。&lt;/p&gt;
&lt;p&gt;暂时没有想到很好的修改方法，但是认为这种情况下，可以像之前整理 &lt;code&gt;static let&lt;/code&gt; 一样来以 &lt;code&gt;static var&lt;/code&gt; 的形式来整理这些布尔类型的标记，可能取 class 名为 GMMarks。&lt;/p&gt;
&lt;p&gt;另外还可以自定义这些标记的 setter，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; imageSelected:&lt;span class=&quot;keyword&quot;&gt;Bool&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以这样自定义 setter：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
    GMMarks.imageSelected = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;
}
class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;deselectImage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {&lt;/span&gt;
    GMMarks.imageSelected = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语义更清晰易懂&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;UIView_耦合&quot;&gt;UIView 耦合&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view1)
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view2)
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubview&lt;/span&gt;(view3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假如说在 ViewController 里面看到上面这样的代码，同时发现 view1、view2、view3 之间就是简单的一层一层叠加而已，那么我们或许可以向之前一样建一个叫做 GMViews 的 class，然后把这三个 view 的创建都放在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;xxView&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(frame frame:CGRect)&lt;/span&gt; -&amp;gt; &lt;span class=&quot;title&quot;&gt;UIView&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一个方法里面，使用时也很简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let xxView = GMViews.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;xxView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(frame: xx)&lt;/span&gt;&lt;/span&gt;
self&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.addSubView&lt;/span&gt;(xxView)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候一定要注意，之前三个 view 在 ViewController 里面创建时，frame 是根据 self.view 这个 view 来写的，frame.origin 是一个 CGPoint，它表示的是相对于父级 view 的相对位置，而不是相对于你的 App 界面的绝对位置，所以抽离这部分代码的时候，确保你的各个 view 的 frame 写对（在支持横屏的时候，是不是还涉及其他问题）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;抽离方法命名问题&quot;&gt;抽离方法命名问题&lt;/h2&gt;&lt;p&gt;MVC 令人诟病的一点是，以前写在 Controller 里面的业务逻辑很臃肿，现在加个 &lt;code&gt;func&lt;/code&gt; 关键字就抽离到 Model 里面，导致 Controller 不臃肿了，Model 反倒臃肿了。&lt;/p&gt;
&lt;p&gt;所以如果想要从之前臃肿的 ViewController 里面抽离到代码到新的类，一定要注意 Model 的命名问题。  &lt;/p&gt;
&lt;p&gt;比如说我现在要清理缓存，清理缓存这种事情应该说和当前的 ViewController 是没什么耦合性可言的，完全可以把这部分代码剥离出来，那么如果这时候我根据清理的具体内容不同，抽象出了三个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; {}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果直接粗暴地把这三个方法填到一个叫做 GMTools 的类里面，把这些方法都加上  &lt;code&gt;class&lt;/code&gt; 关键字，那么以后这个类会越来越杂乱，这和之前没什么分别。&lt;/p&gt;
&lt;p&gt;较好的做法应该是把这个类叫做 GMClear，而且尽量调用方法的时候，让方法体内部的逻辑和现在的这个 App 本身没太大关系，把和现在的 App 有直接关系的部分作为参数，让使用者传参调用。&lt;/p&gt;
&lt;p&gt;这样下来，或许你可以在这个项目结束的时候，拥有几个可能叫 GMClear、GMSave、GMShare 的类，而且这些类里面的方法和你现在这个 App 没有太多直接联系，那么下一个项目用到这些东西，直接把代码文件复制过去就可以了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;最近在重构一个以前写的老项目，在尝试给之前的 ViewController 减负，尽量抽离代码到其他文件。&lt;br&gt;想记录一些东西，看看以后返回来再看能不能有更好的想法；而现在，可以作为一个检验当前代码是否需要优化的一个标准。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>实习求职终结篇</title>
    <link href="/2016/04/15/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E7%BB%88%E7%BB%93%E7%AF%87/"/>
    <id>/2016/04/15/实习求职终结篇/</id>
    <published>2016-04-15T14:01:39.000Z</published>
    <updated>2016-08-23T01:27:28.000Z</updated>
    
    <content type="html">&lt;p&gt;在和腾讯、阿里各通了4次电话之后，翘掉了腾讯的最后一面（因为是在隔壁的城市，而且是群面，心理上有点抗拒），拿到了阿里无线事业部的 offer，个人还是很满意，反过来记录一下整个过程，分享一下。&lt;/p&gt;
&lt;h2 id=&quot;做简历&quot;&gt;做简历&lt;/h2&gt;&lt;p&gt;大概2月底的时候，感觉到各大公司都开始有招聘的苗头了，了解到腾讯是3月底截止内推，其他公司也差不多。然后迅速撰写草稿，用一晚上的时间完成了简历的制作，虽然后来也修改了简历，但是第一版已经确定了 80% 的内容。这里面有一点要提一下，关于如何做简历（制作，不是简历的内容）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我个人的简历是“维护”了4个版本的：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个 txt 或者 rtf 用来放纯文本的信息，这是你的 PDF 版的简历的内容来源。因为无论用 pages 还是 word 还是其他工具来做简历，难免要有格式、图片等等其他元素，会影响到你撰写信息，所以需要有一个纯文本用来撰写信息，以此为数据源来更新你最终简历上的内容。&lt;/li&gt;
&lt;li&gt;一个 pages（或 word 等）文档，这是随时用来修改并且导出 PDF 版简历的。&lt;/li&gt;
&lt;li&gt;PDF 版简历，这个简历的命名要写好，可以写成【简历_iOS开发实习_姓名】，这样任何时候需要简历，都可以直接发过去，命名可以让人一眼看出这是什么文件。&lt;/li&gt;
&lt;li&gt;一个 JPG 版本，虽然正式简历不该用图片，但是万一有机会在微信或者微博上发现有机会和别人私聊拿到工作机会，手机上是不能在微信和微博客户端发 PDF 的，所以这个也要准备好，而且要在清晰度高的同时保证文件不要太大，10M 的图片发出去都费劲。&lt;br&gt;（如果想参考的话，可以&lt;a href=&quot;https://github.com/OpenMarshall/MyResume/raw/master/%E7%AE%80%E5%8E%86_iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0_%E5%BE%90%E5%BC%80%E6%BA%90.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击下载我的简历&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;找内推&quot;&gt;找内推&lt;/h2&gt;&lt;p&gt;在各个公司的内推期间，我拿到了腾讯、阿里、网易、蘑菇街4家的内推（京东也可以拿的，但是他们竟然不招 iOS 开发），而最终给我 offer 的阿里，帮我内推的人我压根就不认识，或许当初没有间接找人内推阿里，我现在连个机会都没有。&lt;/p&gt;
&lt;p&gt;所以想说，只要认真去联系一下，找一找中间人，其实联系上哪家公司的员工都不难。因为觉得自己不认识这家公司的人，就想不走内推流程或者干脆不去应聘，实在太可惜了。&lt;/p&gt;
&lt;h2 id=&quot;电面&quot;&gt;电面&lt;/h2&gt;&lt;p&gt;非常感谢腾讯的师兄，因为他的帮忙，我同时接到了手机 QQ 和微云两个部门的电面，所以按说只有两轮的电面，我接到了4次，涨了不少经验。之前的文章：&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/08/%E8%85%BE%E8%AE%AF-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯 iOS 开发实习电话面试记录（一）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/16/%E8%85%BE%E8%AE%AF-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯 iOS 开发实习电话面试记录（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里这边是手机淘宝部门，一路都很顺利，一面打了7分钟电话，都是简单问题（运气好重要），二面没聊技术（和我个人简历有关），三面是正规的技术面，四面HR是很普通的聊天。之前的文章：&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/19/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里 iOS 开发实习电话面试记录（一）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kyxu.tech/2016/03/29/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里 iOS 开发实习电话面试记录（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里可以给的一点建议是：不要遇到答不出来的问题就一个字都不说，猜也好、临时分析也好，至少展现一点主动分析问题的状态。&lt;/p&gt;
&lt;h2 id=&quot;笔试&quot;&gt;笔试&lt;/h2&gt;&lt;p&gt;这里还是想吐槽一下，这些大公司都有些偷懒，笔试页面一看就是外包项目，感觉是建了一个题库，考试的时候直接从题库随机抽题目。&lt;/p&gt;
&lt;p&gt;笔试非常考验 CS 基础，数据库、操作系统、计算机网络、算法、C++ 的东西会的越多越好（实际上也确实是会的越多越好）。但是给客户端开发实习生同一套题目我实在是不服，有些 Android 题目给我做真是题都没看懂……&lt;/p&gt;
&lt;p&gt;不过趟基础也不是三两天可以搞定的，只能推荐个我个人觉得还不错的&lt;a href=&quot;http://www.nowcoder.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;刷题网站&lt;/a&gt;。还有就是，虽然在线笔试的网站监测作弊的手段并不强，还是劝想作弊的人不要这么干，抛开道德准则不说，万一出事，后果太严重了。&lt;/p&gt;
&lt;h2 id=&quot;寻求更多机会&quot;&gt;寻求更多机会&lt;/h2&gt;&lt;p&gt;虽然我给十多家小公司发了邮件没有收到任何回复，但是认为广投简历、对这些信息敏感一点总是好的。&lt;br&gt;在阿里四面之前，我就直接或间接地通过微博拿到了一家小公司（不便透露名称）的 offer 还有去饿了么做 React Native 的机会。&lt;br&gt;所以，主动一点吧～&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在和腾讯、阿里各通了4次电话之后，翘掉了腾讯的最后一面（因为是在隔壁的城市，而且是群面，心理上有点抗拒），拿到了阿里无线事业部的 offer，个人还是很满意，反过来记录一下整个过程，分享一下。&lt;/p&gt;
&lt;h2 id=&quot;做简历&quot;&gt;做简历&lt;/h2&gt;&lt;p&gt;大概2月底的时候，感觉到
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>扯淡 Method Swizzling</title>
    <link href="/2016/04/06/%E6%89%AF%E6%B7%A1-Method-Swizzling/"/>
    <id>/2016/04/06/扯淡-Method-Swizzling/</id>
    <published>2016-04-06T03:11:29.000Z</published>
    <updated>2016-04-09T15:56:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;&lt;p&gt;关于 Method Swizzling 这个东西，已经有很多高人写了详细的文章来介绍，我就不再班门弄斧，往深了说了。&lt;br&gt;而且不作延伸的话，这项技术本身也没有复杂到要长文论述的地步。&lt;br&gt;本文旨在帮助不熟悉这项技术的人，开始在实际开发过程中，尝试使用它。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;这是个啥&quot;&gt;这是个啥&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;swizz 这个词在英语里面是“欺骗”的意思。&lt;br&gt;Method Swizzling 也叫做“方法调配”、“方法混合”、“方法调和”，&lt;strong&gt;是用来互换两个方法的实现的技巧。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这东西并不常用，比如我们用方法 A 实现了 a 这件事，方法 B 实现了 b 这件事，现在你非要用 A 实现 b，B 实现 a，即便技术上是可行的，你图个啥？回头再换回来你还记得不？再换第三次呢？&lt;/li&gt;
&lt;li&gt;那么什么时候可能需要用到这个东西呢？调试的时候。&lt;br&gt;如果方法 A、B 我都知道怎么实现的，那确实不用换。但是假如方法 A 的实现被隐藏了，那么我是不是可以用方法 B 调用方法 A，再顺便添加点别的功能，然后进行 A、B 实现 swizz。&lt;br&gt;这样再调用方法 A 的时候，就多了一点我们之前顺便添加的功能。&lt;br&gt;有人会说，你这有意思么，你直接调用方法 B 不就得了，为啥还要换？重点在于，方法 A 如何被调用可能不是我们可以决定的啊。或许这个方法已经在无数个地方被调用了无数次，那我想批量替换的话，当然就可以 swizz 了。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;举栗子&quot;&gt;举栗子&lt;/h3&gt;&lt;p&gt;比如说，在某个项目中，NSArray 实例的下面这个方法被调用了 N 多次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containsObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我想调试一下，看看如果这个方法返回 true，即数组包含我们传入的元素的时候，这个元素在数据的什么位置（index）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;indexOfObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然直接调用上面这个方法就可以知道 index，但是 &lt;code&gt;containsObject&lt;/code&gt; 被使用了太多次，Xcode 现在又不支持 Swift 重构，懒得改了。那就写个新方法，给原方法加个可以输出 index 的功能，再用 swizz 替换一下两个方法的实现吧。&lt;/p&gt;
&lt;p&gt;这里我贴了完整的一个 demo 的代码，你可以直接粘到 Xcode 里面运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; UIKit

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()

        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;(array: [&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Method&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Swizzling&quot;&lt;/span&gt;])

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 之前-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;

        &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.swizz() &lt;span class=&quot;comment&quot;&gt;// 方法互换&lt;/span&gt;

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 之后-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// 先输出 index，再 true&lt;/span&gt;

        &lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.swizz() &lt;span class=&quot;comment&quot;&gt;// 方法再换回来&lt;/span&gt;

        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-----Swizzling 两下-----&quot;&lt;/span&gt;)
        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.containsObject(&lt;span class=&quot;string&quot;&gt;&quot;Swift&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;
    }

}

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSArray&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;comment&quot;&gt;// 用来和默认方法进行替换的方法&lt;/span&gt;
    &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myContainsObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(anObject: AnyObject)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; {
        &lt;span class=&quot;comment&quot;&gt;// 输出元素的 index，这是默认的原方法不具有的功能&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.myContainsObject(anObject) {
            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;index：\\(self.indexOfObject(anObject))&quot;&lt;/span&gt;)
        }
        &lt;span class=&quot;comment&quot;&gt;// 不会产生死循环，因为运行期间，下面的方法已经被替换成了默认的 containsObject&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.myContainsObject(anObject)
    }

    &lt;span class=&quot;comment&quot;&gt;// 用来给不同方法互相替换的方法&lt;/span&gt;
    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swizz&lt;/span&gt;() &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; originalMethod = class_getInstanceMethod(&lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, #selector(containsObject(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;:)))
        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; swizzledMethod = class_getInstanceMethod(&lt;span class=&quot;type&quot;&gt;NSArray&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, #selector(myContainsObject(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;:)))
        method_exchangeImplementations(originalMethod, swizzledMethod)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-7f3a68b6ef76a5af.png&quot; alt=&quot;console&quot;&gt;&lt;br&gt;【注意几点】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这里我先后调用了三次 &lt;code&gt;containsObject&lt;/code&gt; 这个方法，其中第二次，它的内部实现被  &lt;code&gt;myContainsObject&lt;/code&gt; 这个方法的内部实现替换掉了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myContainsObject&lt;/code&gt; 这个方法乍一看是死循环，如果你直接调用它的话，它也确实是死循环。但现在我们是在 RunTime 期间，动态地决定这个方法的内部实现的，在我们调用这个方法，进入它的函数体的时候，它的实现就已经被换掉了，所以在它的内部，你应该把 &lt;code&gt;myContainsObject&lt;/code&gt; 这个词在你的脑子里换成 &lt;code&gt;containsObject&lt;/code&gt;（如果确定此时两个方法确实互换了实现）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;&lt;p&gt;如果我写的这点东西可以帮助你以后的 debug 工作，那么最好。&lt;br&gt;如果你要在实际项目里用它……你要是真能用上也挺厉害。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;&lt;p&gt;关于 Method Swizzling 这个东西，已经有很多高人写了详细的文章来介绍，我就不再班门弄斧，往深了说了。&lt;br&gt;而且不作延伸的话，这项技术本身也没有复杂到要长文论述的地步。&lt;br&gt;本文旨在帮助不熟悉这项技术的人，开始
    
    </summary>
    
    
      <category term="iOS 开发" scheme="/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里 iOS 开发实习电话面试记录（二）</title>
    <link href="/2016/03/29/%E9%98%BF%E9%87%8C-iOS-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>/2016/03/29/阿里-iOS-开发实习电话面试记录（二）/</id>
    <published>2016-03-29T06:58:00.000Z</published>
    <updated>2016-04-09T15:57:20.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 客户端开发的三面。&lt;/p&gt;
&lt;p&gt;这次的面试官，一听他说话，年纪就不小了，感觉差不多也是个全栈。他问的 iOS 相关的问题我 90% 都答上来了，提到操作系统、计算机网络、算法之类的，我直说因为长期不投入实用，都忘了，他就说那就不问这方面的了，最后还劝告说，这些更多是方法论的东西，建议我学好，下面是他问了的 iOS 相关的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;（我在简历上写自己独立开发了几个 App）说一下你自己做的那个 App（随便挑了一个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（我大概阐述了产品方向之后，他问我技术上最难的是什么，然后随口提到了要保存图片到相册）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于 iOS 系统相册，有哪些相关方案可以获取？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以前的 AssetsLibrary 和现在的 Photos 框架都知道吗？&lt;br&gt;（我说了关于现在引入 Photos 和 PhotosUI 之后可以获取 LivePhoto 的问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;都熟悉哪些框架，有没有特别了解的？&lt;br&gt;（我说我熟悉 WebKit，然后他就问了我 GCD = =）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（发现我会用 GCD 之后）能不能说一下底层？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（我说我知道点 ARC 相关的底层实现，就说了一通，他很满意，这里要强烈推荐下面这本书）&lt;br&gt;&lt;img src=&quot;http://7xssu3.com2.z0.glb.clouddn.com/251884-7b1d63a98ab4148d.png&quot; alt=&quot;Objective-C 高级编程&quot;&gt;&lt;br&gt;同类型的问题还有 assign、weak 的区别，ARC 如何实现，编译时、运行时区别，weak 属性的对象在废弃后 指针是如何指向 nil 的……&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平时了解一些架构吗？&lt;br&gt;（我说我知道 MVC、MVVM。其他的光知道没用过，不敢拿出来装B）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;说一下 MVVM&lt;br&gt;（泪奔，难得在面试的时候能碰上自己很熟悉的，推荐不熟悉的看看最近挺火的文章&lt;a href=&quot;https://realm.io/cn/news/doios-natasha-murashev-protocol-oriented-mvvm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《面向协议的 MVVM 架构介绍》&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知道 KVO、KVC 吗？&lt;br&gt;（虽然这个东西大家都在用，但是查一下还是能查出来一些自己不知道的，心里没底的，建议现在就去 Google 一下）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你平时做 App 之后，有什么推广途径？&lt;br&gt;（其中我提到了一些推广平台，国内的有 36Kr 的 &lt;a href=&quot;http://next.36kr.com/posts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NEXT&lt;/a&gt;、爱范儿的 &lt;a href=&quot;http://mindstore.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MindStore&lt;/a&gt; 和 &lt;a href=&quot;https://itunes.apple.com/app/id966457637&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AppSo&lt;/a&gt;，国外的有 &lt;a href=&quot;https://www.producthunt.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProductHunt&lt;/a&gt;，好像他在听的时候还在一边拿笔记，人家也还在学习啊~）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 客户端开发的三面。&lt;/p&gt;
&lt;p&gt;这次的面试官，一听他说话，年纪就不小了，感觉差不多也是个全栈。他问的 iOS 相关的问题我 90% 都答上来了，提到操作系统、计算机网络、算法之类的，我直说因为长期不投入实用，都忘了，他就说那就不问这方面的了，最后还劝告说，这些更多
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
